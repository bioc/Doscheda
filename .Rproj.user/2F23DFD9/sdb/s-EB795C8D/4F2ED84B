{
    "collab_server" : "",
    "contents" : "# https://bruniec.shinyapps.io/doscheda/\n\nlibrary(hexbin)\nlibrary(MASS)\nlibrary(shiny)\nlibrary(shinydashboard)\nlibrary(stringr)\nlibrary(affy)\nlibrary(limma)\nlibrary(DT)\nlibrary(ggplot2)\nlibrary(vsn)\nlibrary(gridExtra)\nlibrary(lattice)\nlibrary(corrgram)\nlibrary(calibrate)\nlibrary(reshape2)\nlibrary(readxl)\nlibrary(MASS)\nlibrary(lazyeval)\nlibrary(drc)\nlibrary(httr)\nlibrary(jsonlite)\nlibrary(rmarkdown)\nlibrary(dplyr)\nlibrary(d3heatmap)\nlibrary(prodlim)\n\n\n################### Load Function\n\nloadingLogo <- function( src, loadingsrc, height = NULL, width = NULL, alt = NULL) {\n  tagList(\n    tags$head(\n      tags$script(\n        \"setInterval(function(){\n        if ($('html').attr('class')=='shiny-busy') {\n        $('div.busy').show();\n        $('div.notbusy').hide();\n        } else {\n        $('div.busy').hide();\n        $('div.notbusy').show();\n        }\n},100)\")\n  ),\n  tags$a(\n    div(class = \"busy\",\n        img(src=loadingsrc,height = height, width = width, alt = alt)),\n    div(class = 'notbusy',\n        img(src = src, height = height, width = width, alt = alt))\n  )\n    )\n  }\n\n\n# plotting functions for sigmoidal\nshape_for_ggplot_pred<-function(df_ordered,conc,pred.names){\n  cols_to_keep_pred<-c(pred.names,\"GeneID\",\"Accession\")\n\n  forggplot_pred<-vector(mode = \"list\",length = length(df_ordered$GeneID))\n\n  for(i in 1:length(df_ordered$GeneID)){\n    tmp_pred<-df_ordered[,cols_to_keep_pred]\n    forggplot_pred[[i]]<-melt(tmp_pred[i,], id = c(\"GeneID\", \"Accession\"), na.rm = TRUE)\n  }\n\n  forggplot_pred_1<-do.call(rbind, forggplot_pred)\n  forggplot_pred_1<-data.frame(forggplot_pred_1,\"x\"=conc)\n  #return(forggplot_pred_1)\n}\n\nshape_for_ggplot_perc<-function(df_ordered,conc,finalNames){\n  cols_to_keep_perc<-c(finalNames, \"GeneID\",\"Accession\")\n\n  forggplot_perc<- vector(mode = \"list\",length = length(df_ordered$GeneID))\n  for(i in 1:length(df_ordered$GeneID)){\n    tmp_perc<-df_ordered[,cols_to_keep_perc]\n    forggplot_perc[[i]]<-melt(tmp_perc[i,], id = c(\"GeneID\", \"Accession\"), na.rm = TRUE)\n  }\n\n  forggplot_perc_1<-do.call(rbind, forggplot_perc)\n  forggplot_perc_1<-data.frame(forggplot_perc_1,\"x\"=conc)\n  #return(forggplot_perc_1)\n}\n\n\npie_chart <- function(df, main, labels = NULL, condition = NULL) {\n\n  # convert the data into percentages. group by conditional variable if needed\n  df <- group_by_(df, .dots = c(condition, main)) %>%\n    summarise(counts = n()) %>%\n    mutate(perc = counts / sum(counts)) %>%\n    arrange(desc(perc)) %>%\n    mutate(label_pos = cumsum(perc) - perc / 2,\n           perc_text = paste0(round(perc * 100), \"%\", \"\\n\",\"(\",counts, \")\"))\n\n  # reorder the category factor levels to order the legend\n  df[[main]] <- factor(df[[main]], levels = unique(df[[main]]))\n\n  # if labels haven't been specified, use what's already there\n  if (is.null(labels)) labels <- as.character(df[[main]])\n\n  p <- ggplot(data = df, aes_string(x = factor(1), y = \"perc\", fill = main)) +\n\n    # make stacked bar chart with black border\n    geom_bar(stat = \"identity\", color = \"black\", width = 1) +\n\n    # add the percents to the interior of the chart\n    geom_text(aes(x = 1.25, y = label_pos, label = perc_text), size = 4) +\n\n    # add the category labels to the chart\n    # increase x / play with label strings if labels aren't pretty\n    geom_text(aes(x = 1.82, y = label_pos, label = labels), size = 4) +\n\n    # convert to polar coordinates\n    coord_polar(theta = \"y\") +\n\n    # formatting\n    scale_y_continuous(breaks = NULL) +\n    scale_fill_discrete(name = \"\", labels = unique(labels)) +\n    theme(text = element_text(size = 12),\n          axis.ticks = element_blank(),\n          axis.text = element_blank(),\n          axis.title = element_blank())\n\n  # facet wrap if that's happening\n  if (!is.null(condition)) p <- p + facet_wrap(condition)\n\n  return(p)\n}\n\n\n##upload kinase file\nkinome1<-read.csv(file=\"KinaseFile.csv\",  header=TRUE, sep=\",\")\nkinome<-as.vector(toupper(kinome1$new.Symbol))\n\nlogvc<- function(x) sqrt(exp(x*log(2))^2 - 1 )\n\n# Peptide matching function\n\npeptide.match<- function(dr1,dr2,nchan){\n  maxrow <- max(nrow(dr1),nrow(dr2))\n  minrow <- min(nrow(dr1),nrow(dr2))\n\n  adVal <- maxrow - minrow\n\n  if(nrow(dr1) == maxrow){\n    dr2$addedVals <- adVal\n    big.pep <- dr1\n    small.pep <- dr2\n  } else {\n    dr1$addedVals <- adVal\n    big.pep <- dr2\n    small.pep <- dr1\n  }\n\n\n  newframe <- big.pep\n  colnames(newframe) <- colnames(small.pep)\n  newframe[1:minrow,] <- small.pep\n\n  for(i in  1:nchan){\n\n    newframe[(minrow+1):maxrow,i]<- mean(small.pep[,i])\n  }\n\n\n  if (all.equal(dim(big.pep),dim(dr1)) == TRUE){\n\n    dr2 <- newframe\n  } else {\n    dr1 <- newframe\n  }\n\n  list(dr1 = dr1, dr2 = dr2 )\n}\n\npanel.shadeNtext <- function (x, y, corr = NULL, col.regions, ...)\n{\n  if (is.null(corr))\n    corr <- cor(x, y, use = \"\n                pair\")\n  ncol <- 14\n  pal <- col.regions(ncol)\n  col.ind <- as.numeric(cut(corr, breaks = seq(from = -1, to = 1,\n                                               length = ncol + 1), include.lowest = TRUE))\n  usr <- par(\"usr\")\n  rect(usr[1], usr[3], usr[2], usr[4], col = pal[col.ind],\n       border = NA)\n  box(col = \"lightgray\")\n  on.exit(par(usr))\n  par(usr = c(0, 1, 0, 1))\n  r <- formatC(corr, digits = 2, format = \"f\")\n  cex.cor <- .8/strwidth(\"-X.xx\")\n  text(0.5, 0.5, r, cex = cex.cor)\n}\n\n#########################################################################\n## UI\n#########################################################################\n\nui <- shinyUI(dashboardPage(\n  dashboardHeader(title = loadingLogo('titleogo.png','logogifopt.gif',height = 55,width = 165)),\n  dashboardSidebar(\n    sidebarMenu(id = \"menu1\",\n\n                menuItem(text = \"Introduction\", tabName = \"intro\"),\n                #menuItem(text = \"Step by Step Guide\", tabName = 'stbyst'),\n                conditionalPanel(\n                  condition = \"input.menu1 == 'stbyst'\",\n                  radioButtons(inputId = \"stage\",label = NULL, choices =\n                                 c(\"Stage 1: Data Upload\" = \"stage1\",\n                                   \"Stage 2: Navigating Plots\" = \"stage2\",\n                                   \"Stage 3: Download Results\" = \"stage3\"))\n                ),\n\n                menuItem(text = \"Data Upload\", tabName = \"dataload\"),\n                menuItem(text = \"Box and Density Plots\", tabName = \"box\"),\n                menuItem(text = \"MeanSD Plot\", tabName = \"meansd\"),\n                menuItem(text = \"Mean vs Difference\", tabName = \"meandiff\"),\n                conditionalPanel(\n                  condition = \"input.menu1 == 'meandiff'\",\n                  uiOutput(\"meandiff1\")\n                ),\n                menuItem(text = \"Corrgram\",tabName = \"corrgram\"),\n                menuItem(text = \"Compare Replicates\",tabName = \"repvsrep\"),\n                conditionalPanel(\n                  condition = \"input.menu1 == 'repvsrep'\",\n                  uiOutput(\"repvsrep1\") ),\n                menuItem(text = \"PCA\", tabName = \"pca\"),\n                menuItem(text = \"Heatmap\", tabName = \"testsigmoid\"),\n                menuItem(text = \"Linear Model\", tabName = \"volcano\"),\n                conditionalPanel(\n                  condition = \"input.menu1 == 'volcano' & input.modtyp == 'lin'\",\n                  sliderInput(inputId = \"pvalsli\", label = \"Change Pvalue threshold\",min = 0,max = 0.1,value = 0.05),\n                  sliderInput(inputId = \"avthrssli\", label = \"Change avfold threshold\",min = 0,max = 1,value = 0.2)\n                ),\n                menuItem(text = \"Sigmoidal fit\",tabName = \"sigfit\"),\n                menuItem(text = \"Summary\", tabName = \"summary\"),\n                menuItem(text = \"Download\", tabName = \"download\"),\n                menuItem(text = \"Session Log\", tabName = \"tst\")\n\n\n\n    )\n  ),\n\n  dashboardBody(\n    tabItems(\n       tabItem(tabName = 'tst',box(htmlOutput(\"sessionInfo\"),width = 12)),\n      tabItem(tabName = \"testsigmoid\",\n              box(width = 12, height = 800,\n                  d3heatmapOutput(\"plot9\",height = 750)\n              )),\n\n\n      tabItem(tabName = \"intro\",  includeHTML(path =\"introduction.html\")),\n      # The step by step has been removed from the app but can be re instated by including the menuItem at the start of the UI\n      tabItem(tabName = \"stbyst\",\n              conditionalPanel(condition = 'input.stage == \"stage1\"',\n                               tabBox(id = 'stg1tabs', width = 12,\n                                      tabPanel(title = \"Step 1\",\n                                               h4(\"Go to the tab on the sidebar\"),\n                                               br(),br()\n                                               ,HTML('<p><img src=\"stage1step1.gif\" height = 500 /></p>')\n                                      ),\n                                      tabPanel(title = \"Step 2\",\n                                               h4(\"Select your data type, please note that intensities will take a few minutes to run.\"),\n                                               br(),HTML('<p><img src=\"stage1step2.gif\" height = 450 /></p>')\n\n                                      ),\n                                      tabPanel(title = \"Step 3\",\n                                               h4(\"Select the number of channels and replicates.\"),\n                                               br(),\n                                               HTML('<p><img src=\"stage1step3.gif\" height = 450 /></p>')\n                                      ),\n                                      tabPanel(title = \"Step 4\",\n                                               h4(\"Choose the columns from your data set which indicate the channels you would like to analyse. Note that you can search for these column names by typing in the input box.\"),\n                                               br(),h4(\"Remember to check that the uploaded column names correspond with the correct standardised name by looking at the table. You can change these positions by dragging and dropping the selected column names in the desired order in the input box.\"),\n                                               br(),HTML('<p><img src=\"stage1step4.gif\" height = 450 /></p>')\n                                      ),\n                                      tabPanel(title = \"Step 5\",\n                                               h4(\"(optional depending on input) If you would like to apply a sigmoidal fit and have an adequate amount of data, use the radio button to change the fit and input your concentrations, separating them with a comma\n                                                  . Please Note that this may take a few minutes to run\"),\n                                               br(),HTML('<p><img src=\"doschedasigmoid.gif\" height = 450 /></p>')\n                                      ),\n                                      tabPanel(title = \"Step 6\",\n                                               h4(\"(optional depending on input)  If you are using intensities, you required to input the peptide quality score and  sequence.\"),\n                                               br(),HTML('<p><img src=\"doschedaintensity.gif\" height = 450 /></p>')),\n                                      tabPanel(title = \"Step 7\",\n                                               h4(\"Change to one of the plot tabs and you will see the loading sign appear in place of the logo, now cycle through all the tabs.\")\n                                      )\n\n                               )),\n              conditionalPanel(condition = 'input.stage == \"stage2\"'\n                               ,\n                               tabBox(id = 'stg2tabs', width = 12,\n                                      tabPanel(title = \"Stage 2\",\n                                               h4(\" Cycle through plots, this is done by clicking on the sidebar tabs and the tabs within the main panel.\")\n                                      ))\n\n              ),\n              conditionalPanel(condition = 'input.stage == \"stage3\"'\n                               ,\n                               tabBox(id = 'stg3tabs', width = 12,\n                                      tabPanel(title = \"Download Data\",\n                                               h4(\"Go to the Download tab and press the Download Data button to download the processed data in csv format. and use the â€˜Download Reportâ€™ to download a html file with all your plots with descriptions with them to save your results from the pipeline.\")\n                                      ),\n                                      tabPanel(title = \"Download Report\",\n                                               h4(\"Go to the Download tab and press the â€˜Download Reportâ€™ button to download a html file with all your plots with description, allowing you to save your results from the pipeline.\")\n\n                                      )\n\n                               )\n\n\n              )),\n      # End of the step by step\n\n      tabItem(tabName = \"dataload\",\n              box(width = 4,\n\n\n                  fluidRow(column(5,radioButtons(\"datype\", \"Data Type:\",\n                                                 c(\"Intensities\" = \"intensity\",\n                                                   \"Fold Change\" = \"FC\",\n                                                   \"Log-Fold Change\" = \"lFC\"))),\n\n                           column(5,radioButtons(\"filetype\", \"File Type:\",\n                                                 c(\".csv\" = \"CSV\",\n                                                   \".txt\" = \"TXT\",\n                                                   \".xlsx\" = \"XLSX\")))\n                  ),\n\n                  conditionalPanel(condition = 'input.datype == \"intensity\" & input.modtyp != \"sigmoid\"',\n                                   radioButtons(\"dorem\", \"Do removal:\",\n                                                c(\"Yes\" = \"yes\",\n                                                  \"No\" = \"no\"),selected = 'no')\n\n                  )\n                  ,\n\n\n\n                  # DATA file upload\n                  fileInput('file2', 'Choose file',\n                            accept = c(\".txt\",\".csv\",\".xlsx\")),\n\n                  fluidRow(column(5, numericInput(\"chans\",\"# Channels\",value = 4, min = 1)),\n                           column(5, numericInput(\"reps\",\"# Replicates\",value = 1,min = 1))\n                  ),\n\n                  actionButton(\"changenames\", label = \"Change Names\"),\n\n                  conditionalPanel(condition = \"(input.changenames % 2) == 1\",\n\n                                   uiOutput(\"setNames\")\n\n                  ),\n                  uiOutput(\"ui_choice\"),\n                  conditionalPanel(condition = 'input.datype == \"intensity\"',\n\n                                   uiOutput(\"ui_sequence\"),\n                                   uiOutput(\"ui_qual\"),\n                                   numericInput('pearsvar',label = \"Pearson Variable\", value = 0.4,min = -1,max = 1,step = 0.1),\n                                   radioButtons(inputId = \"normalize\",label = 'Choose Normalization', choices =\n                                                  c(\"LOESS\" = \"loess\",\n                                                    \"Median\" = \"median\",\n                                                    \"None\" = \"none\"),\n                                                selected = 'loess'\n                                                )\n\n\n                  ),\n                  conditionalPanel(condition = 'input.toacc == true || input.datype == \"intensity\"',\n                                   uiOutput(\"ui_accession\")\n\n                  ),\n                  conditionalPanel(condition = 'input.toacc == true & input.datype != \"intensity\"',\n                                   uiOutput(\"ui_uniqpep\")\n\n                  ),\n\n                  conditionalPanel(condition = \"input.modtyp == 'sigmoid'\",\n                    checkboxInput('incpd', 'Insert pulldown of pull down', value = FALSE)\n\n                  ),\n                  conditionalPanel(condition = 'input.incpd == true',\n                                   uiOutput(\"ui_pdofpd\")\n\n                  ),\n                  conditionalPanel( condition =  \"input.datype != 'intensity'\",\n\n                                    checkboxInput(\"toacc\", \"Data is NOT Proteome Discoverer 2.1\", FALSE)\n                  ),\n\n                  checkboxInput('genefile', 'Upload an Accession to Gene ID file', value = FALSE)\n\n\n                  # uiOutput(\"ui_sequence\"),\n                  ## remove column obselete\n\n                  # fluidRow(\n                  # column(5,conditionalPanel(\n                  #   condition = \"input.conf != 0\",\n                  #   actionButton(inputId = \"removechan\", label = \"Remove Column\")\n                  # ))),\n                  #\n                  # conditionalPanel(\n                  #   condition = \"(input.removechan % 2) == 1\",\n                  #   uiOutput(\"remchan\")\n                  # )\n\n              ),\n              box(width = 8,\n                  DT::dataTableOutput(\"test\")\n              ),\n              box(width = 8,\n                  conditionalPanel(condition = 'input.chans >= 5 & input.reps == 1',\n                                   radioButtons(\"modtyp\", \"Fit model:\",\n                                                c(\"Sigmoidal\" = \"sigmoid\",\n                                                  \"Linear\" = \"lin\"\n                                                ),selected = \"lin\")),\n                  conditionalPanel(condition = 'input.chans < 5',\n                                   h1(\"Less than 5 channels, only a linear model can be applied\")\n                  ),\n                  conditionalPanel(condition = \"input.modtyp == 'sigmoid'\",\n                                   textInput(\"concsig\", \"Enter vector of concentrations from low to high [comma delimited]. Ensure these are not log concentrations\"),\n                                   textOutput(\"concsig\")\n\n\n                  )\n              ),\n\n              box(width = 8,\n                  selectizeInput( 'organism',label = 'Select your organism:', choice = c('H.sapiens','C. familiaris','D.melanogaster','M. musculus','R. norvegicus',  'S.cerevisiae'), selected =  'H.sapiens'),\n                  conditionalPanel(condition = 'input.genefile == true',\n\n                                   fluidRow(column(5,fileInput('geneF', 'Choose you Accession to Gene ID file',\n                                                               accept = c(\".txt\",\".csv\",\".xlsx\"))),\n                                            column(5,radioButtons(\"generadio\", \"File Type:\",\n                                                                  c(\".csv\" = \"CSV\",\n                                                                    \".txt\" = \"TXT\",\n                                                                    \".xlsx\" = \"XLSX\"))\n\n                                            ))\n                  )\n                  )\n      ),\n\n      tabItem(tabName = \"box\",\n\n              fluidRow(\n                tabBox(id = \"tb1\", width = 9, height = 700,\n                       tabPanel(\"Box\",plotOutput(height = 700, \"bar\")),\n                       tabPanel(\"Density\", plotOutput(height = 700, \"plot2\")),\n                       tabPanel(\"Venn\", plotOutput(height = 700, \"venn\"))\n\n\n                ),\n                box(width = 3,\n                    conditionalPanel(condition = \"input.tb1 == 'Venn'\",\n\n                                     checkboxInput(inputId = 'venninput' ,label = 'Include file', value = FALSE)\n                    ),\n                    conditionalPanel('input.venninput == true',\n                                     radioButtons(\"filetype2\", \"File Type:\",\n                                                  c(\".csv\" = \"CSV\",\n                                                    \".txt\" = \"TXT\",\n                                                    \".xlsx\" = \"XLSX\")),\n\n                                     fileInput(inputId = 'venninp',label = 'Choose input file',\n                                               accept = c(\".txt\",\".csv\",\".xlsx\")                                                )\n                    )\n                )\n              )\n      ),\n\n      tabItem(tabName = \"meansd\",\n              fluidRow(box(width = 9, height = 700, plotOutput(height = 600, \"plot3\")))),\n      tabItem(tabName = \"meandiff\",\n              fluidRow(\n                box(width = 9, height = 700, plotOutput(height = 600, \"plot6\"))\n              )),\n      tabItem(\"corrgram\", fluidRow(box(width = 9, height = 800, plotOutput(height = 700,\"plot5\")))\n      ),\n      tabItem(\"repvsrep\", fluidRow(box(width = 9, height = 800, plotOutput(height = 700,\"repvsrep\")))),\n\n      tabItem(tabName = \"pca\", fluidRow( box(width = 9, height = 800, plotOutput(height = 700,\"plot7\")))),\n\n      tabItem(tabName = \"volcano\", fluidRow( tabBox(id = \"volplots\", width = 9, height = 800,\n                                                    tabPanel(title = \"P-Value Distribution\",plotOutput(height = 700,\"plot4\")),\n                                                    tabPanel(title = \"Slope\", plotOutput(height = 700,\"plot8\")),\n                                                    tabPanel(title = \"Intercept\", plotOutput(height = 700,\"volcanoint\")),\n                                                    tabPanel(title = \"Quadratic\", plotOutput(height = 700,\"volcanoquad\"))\n      ))),\n      tabItem(tabName = \"sigfit\", fluidRow( tabBox(id = \"sigplots\", width = 10, height = 800,\n                                                   tabPanel(title = \"Difference Top-Bottom\",plotOutput(height = 700,\"DiffTopBottom\")),\n                                                   tabPanel(title = \"RB50\", plotOutput(height = 700,\"RB50\")),\n                                                   tabPanel(title = \"Slope\", plotOutput(height = 700,\"Slope_pl\"))\n\n      ))),\n\n\n      tabItem(tabName = \"summary\", fluidRow(\n        tabBox(id = \"sumtab\", width = 8,\n               tabPanel(\"Data p-values\",div(DT::dataTableOutput(\"testmerge\",width = '100%'),style = \"font-size:90%\")),\n               tabPanel(\"Kinases\", DT::dataTableOutput(\"kintab\"))\n        ),box(title = \"Corrgram QC\", width = 4,\n              infoBoxOutput(outputId = \"corrinfo\",width = 12)\n\n        ),box(title = \"P Value QC\", width = 4,\n\n              conditionalPanel(condition = \"input.modtyp == 'sigmoid'\",\n                               infoBoxOutput(\"siginfodt\",width = 12),\n                               infoBoxOutput(\"siginfoslop\",width = 12),\n                               infoBoxOutput(\"siginfodiff\",width = 12)\n                               ),\n\n              conditionalPanel(condition = \"input.modtyp != 'sigmoid'\",\n                               infoBoxOutput(outputId = \"infopvalslo\",width = 12),\n                               br(),br(),br(), br(),br(), br(),\n\n                               infoBoxOutput(outputId = \"infopvalint\",width = 12),\n                               br(),br(),br(),  br(),br(), br(),\n                               infoBoxOutput(outputId = \"infopvalquad\",width = 12)\n              )\n        )\n      )),\n      tabItem(tabName = \"download\",\n              box(width = 12,\n                  textInput(\"dataset\", \"Filename for Data\", value = \"Doscheda\"),\n\n                  downloadButton('downloadData', 'Download Data'),\n\n                  downloadButton(\"report\", \"Generate report\")\n\n\n\n              ),\n\n              box(width = 12,\n                  conditionalPanel(condition = \"input.datype == 'intensity'\",\n                                   actionButton(inputId = 'intcalc',\"Calculate Removed Peptides\")\n\n                  ), br(),\n\n                  conditionalPanel(condition = \"input.intcalc != 0\",\n\n                                   downloadButton('peprmv', \"Download Removed Peptides\")\n\n                  )\n               )\n\n      )\n\n\n    )\n  )\n\n))\n\n#########################################################\n## SERVER\n#########################################################\n\nserver <- shinyServer(function(input, output) {\n\n  options(shiny.maxRequestSize=100*1024^2)\n  ##############################################\n\n  ## uniprot gene load in any changes to uni prot file will affect this section\n\n  uniprotGene <- reactive({\n\n    if(input$organism == 'H.sapiens'){\n      query = '<query model=\"genomic\" view=\"Protein.primaryAccession Protein.uniprotAccession Protein.genes.symbol\" sortOrder=\"Protein.primaryAccession ASC\" >\n                <constraint path=\"Protein.organism.shortName\" op=\"=\" value=\"H. sapiens\" code=\"A\" />\n      </query>'\n\n      ret=POST('http://www.humanmine.org/humanmine/service/query/results',\n               body=list(query=query, format='json'),\n               encode='form')\n    } else if(input$organism == 'D. melanogaster'){\n\n      query = '<query model=\"genomic\" view=\"Protein.primaryAccession Protein.uniprotAccession Protein.genes.symbol\" sortOrder=\"Protein.primaryAccession ASC\" >\n                <constraint path=\"Protein.organism.shortName\" op=\"=\" value=\"D. melanogaster\" code=\"A\" />\n      </query>'\n\n      ret=POST('http://www.flymine.org/flymine/service/query/results',\n               body=list(query=query, format='json'),\n               encode='form')\n\n    }else if(input$organism == 'M. musculus'){\n      query = '<query model=\"genomic\" view=\"Protein.primaryAccession Protein.uniprotAccession Protein.genes.symbol\" sortOrder=\"Protein.primaryAccession ASC\" >\n        <constraint path=\"Protein.organism.shortName\" op=\"=\" value=\"M. musculus\" code=\"A\" />\n          </query>'\n      ret = POST('http://www.mousemine.org/mousemine/service/query/results',\n                 body=list(query=query, format='json'),\n                 encode='form')\n    }else if (input$organism == 'R. norvegicus'){\n      query = '<query model=\"genomic\" view=\"Protein.primaryAccession Protein.uniprotAccession Protein.genes.symbol\" sortOrder=\"Protein.primaryAccession ASC\" >\n                <constraint path=\"Protein.organism.shortName\" op=\"=\" value=\"R. norvegicus\" code=\"A\" />\n      </query>'\n\n      ret = POST('http://www.ratmine.org/ratmine/service/query/results',\n                 body=list(query=query, format='json'),\n                 encode='form')\n    }else{\n      query = '<query model=\"genomic\" view=\"Protein.primaryAccession Protein.uniprotAccession Protein.genes.symbol\" sortOrder=\"Protein.primaryAccession ASC\" >\n          <constraint path=\"Protein.organism.shortName\" op=\"=\" value=\"C. elegans\" code=\"A\" />\n      </query>'\n\n      ret=POST('http://www.humanmine.org/humanmine/service/query/results',\n              body=list(query=query, format='json'),\n              encode='form')\n    }\n\n    response = jsonlite::fromJSON(httr::content(ret,as='text'))\n\n    data.prots <- response$results[,c(1,3)]\n    colnames(data.prots) <- c('Entry','Gene.names')\n    as.data.frame(data.prots[,1:2],stringsAsFactors = FALSE)\n  })\n\n  ## upload gene file\n\n  uploadGene <- reactive({\n\n    inFile <- input$geneF\n\n    if(is.null(inFile)){\n      return(NULL)\n    }\n    if( input$generadio == \"TXT\"){\n      file.rename(inFile$datapath,\n                  paste(inFile$datapath, \".txt\", sep=\"\"))\n      # read.xlsx(paste(inFile$datapath, \".xlsx\", sep=\"\"),\n      #           sheetIndex = 1, header = TRUE, stringsAsFactors = FALSE)\n      conv<- read.delim(paste(inFile$datapath, \".txt\", sep=\"\"),\n                        header = TRUE,stringsAsFactors = FALSE)\n\n    } else if (input$generadio == \"XLSX\"){\n      file.rename(inFile$datapath,\n                  paste(inFile$datapath, \".xlsx\", sep=\"\"))\n      # paste(inFile$datapath, \".xlsx\", sep=\"\"))\n      # read.xlsx(paste(inFile$datapath, \".xlsx\", sep=\"\"),\n      #           sheetIndex = 1, header = TRUE, stringsAsFactors = FALSE)\n      conv<- read_excel(paste(inFile$datapath, \".xlsx\", sep=\"\"),\n                        sheet = 1)\n\n    } else {\n      file.rename(inFile$datapath,\n                  paste(inFile$datapath, \".csv\", sep=\"\"))\n      # paste(inFile$datapath, \".xlsx\", sep=\"\"))\n      # read.xlsx(paste(inFile$datapath, \".xlsx\", sep=\"\"),\n      #           sheetIndex = 1, header = TRUE, stringsAsFactors = FALSE)\n      conv<- read.csv(paste(inFile$datapath, \".csv\", sep=\"\"), header = TRUE, stringsAsFactors = FALSE)\n      conv<- conv[,-1]\n    }\n\n    conv <- conv[,1:2]\n    colnames(conv) <- c('Entry', 'Gene.names')\n    conv\n  })\n\n## venn diagram intersect file upload\n\nuploadVenn <- reactive({\n\n    if(input$venninput == FALSE){\n      return(NULL)\n    } else{\n    inFile <- input$venninp\n\n    if(is.null(inFile)){\n      return(NULL)\n    }\n    if( input$filetype2 == \"TXT\"){\n      file.rename(inFile$datapath,\n                  paste(inFile$datapath, \".txt\", sep=\"\"))\n      # read.xlsx(paste(inFile$datapath, \".xlsx\", sep=\"\"),\n      #           sheetIndex = 1, header = TRUE, stringsAsFactors = FALSE)\n      conv<- read.delim(paste(inFile$datapath, \".txt\", sep=\"\"),\n                        header = TRUE,stringsAsFactors = FALSE)\n\n    } else if (input$filetype2 == \"XLSX\"){\n      file.rename(inFile$datapath,\n                  paste(inFile$datapath, \".xlsx\", sep=\"\"))\n      # paste(inFile$datapath, \".xlsx\", sep=\"\"))\n      # read.xlsx(paste(inFile$datapath, \".xlsx\", sep=\"\"),\n      #           sheetIndex = 1, header = TRUE, stringsAsFactors = FALSE)\n      conv<- read_excel(paste(inFile$datapath, \".xlsx\", sep=\"\"),\n                        sheet = 1)\n\n    } else {\n      file.rename(inFile$datapath,\n                  paste(inFile$datapath, \".csv\", sep=\"\"))\n      # paste(inFile$datapath, \".xlsx\", sep=\"\"))\n      # read.xlsx(paste(inFile$datapath, \".xlsx\", sep=\"\"),\n      #           sheetIndex = 1, header = TRUE, stringsAsFactors = FALSE)\n      conv<- read.csv(paste(inFile$datapath, \".csv\", sep=\"\"), header = TRUE, stringsAsFactors = FALSE)\n      conv<- conv[,-1]\n    }\n\n    conv\n    }\n  })\n\n  ### crapome file upload\n\n\n\n  crapome<- reactive({\n    if(input$organism == 'S.cerevisiae'){\n      a <- read.csv('CRAPOME_YEAST',stringsAsFactors = FALSE)\n    } else{\n      a <- read.csv('CRAPOME_HUMAN',stringsAsFactors = FALSE)\n    }\n\n    print(head(a))\n    a\n  })\n\n  ### DATA file upload\n\n    data <- reactive({\n\n\n    inFile <- input$file2\n\n    if(is.null(inFile)){\n      return(NULL)\n    }\n    if( input$filetype == \"TXT\"){\n      file.rename(inFile$datapath,\n                  paste(inFile$datapath, \".txt\", sep=\"\"))\n      # read.xlsx(paste(inFile$datapath, \".xlsx\", sep=\"\"),\n      #           sheetIndex = 1, header = TRUE, stringsAsFactors = FALSE)\n      conv<- read.delim(paste(inFile$datapath, \".txt\", sep=\"\"),\n                        header = TRUE,stringsAsFactors = FALSE)\n\n    } else if (input$filetype == \"XLSX\"){\n      file.rename(inFile$datapath,\n                  paste(inFile$datapath, \".xlsx\", sep=\"\"))\n      # paste(inFile$datapath, \".xlsx\", sep=\"\"))\n      # read.xlsx(paste(inFile$datapath, \".xlsx\", sep=\"\"),\n      #           sheetIndex = 1, header = TRUE, stringsAsFactors = FALSE)\n      conv<- read_excel(paste(inFile$datapath, \".xlsx\", sep=\"\"),\n                        sheet = 1)\n\n    } else {\n      file.rename(inFile$datapath,\n                  paste(inFile$datapath, \".csv\", sep=\"\"))\n      # paste(inFile$datapath, \".xlsx\", sep=\"\"))\n      # read.xlsx(paste(inFile$datapath, \".xlsx\", sep=\"\"),\n      #           sheetIndex = 1, header = TRUE, stringsAsFactors = FALSE)\n      conv<- read.csv(paste(inFile$datapath, \".csv\", sep=\"\"), header = TRUE, stringsAsFactors = FALSE)\n    }\n\n\n    data.frame(conv)\n  })\n\n\n    ## ui elements\n  output$ui_accession<- renderUI({\n\n    temp <- data()\n\n    ## using selectizeInput with drag_drop and DT\n    selectizeInput(\"accession\", \"Choose Accession\", choices  = colnames(temp) ,\n                   selected = NULL,\n                   multiple = FALSE,\n                   options = list(plugins = list('remove_button')))\n  })\n\n  output$ui_uniqpep<- renderUI({\n\n    temp <- data()\n\n    ## using selectizeInput with drag_drop and DT\n    selectizeInput(\"unipeps\", \"Choose Unique Peptides\", choices  = colnames(temp) ,\n                   selected = NULL,\n                   multiple = FALSE,\n                   options = list(plugins = list('remove_button')))\n  })\n\n  output$ui_pdofpd<- renderUI({\n\n    temp <- data()\n\n    ## using selectizeInput with drag_drop and DT\n    selectizeInput(\"pdofpd\", \"Choose Pulldown of pulldown\", choices  = colnames(temp) ,\n                   selected = NULL,\n                   multiple = FALSE,\n                   options = list(plugins = list('remove_button')))\n\n  })\n\n\n\n  output$ui_sequence<- renderUI({\n\n    temp <- data()\n\n    ## using selectizeInput with drag_drop and DT\n    selectizeInput(\"sequence\", \"Choose Sequence\", choices  = colnames(temp) ,\n                   selected = NULL,\n                   multiple = FALSE,\n                   options = list(plugins = list('remove_button')))\n  })\n\n  output$ui_choice<- renderUI({\n    reqtemp <- data()\n    req(reqtemp)\n    ## using selectizeInput with drag_drop and DT\n    selectizeInput(\"view_vars\", \"Select variables to show:\", choices  = colNamTot(),\n                   selected = colNamSel(),\n                   multiple = TRUE,\n                   options = list(plugins = list('remove_button', 'drag_drop'), maxItems = nchans()))\n  })\n\n\n\n  output$ui_qual<- renderUI({\n    reqtemp <- data()\n    req(reqtemp)\n    ## using selectizeInput with drag_drop and DT\n    selectizeInput(\"quality\", \"Select Peptide Qvality Score:\", choices  = colNamTot(),\n                   selected = colNamSel(),\n                   multiple = FALSE,\n                   options = list(plugins = list('remove_button', 'drag_drop'), maxItems = 1))\n  })\n\n  output$remchan<- renderUI({\n    reqtemp <- data()\n    req(reqtemp)\n\n    selectizeInput(\n      'remchan', 'Choose Channels to remove', choices = finalNames(), multiple = TRUE,\n      options = list(plugins = list('remove_button'))\n    )\n\n  })\n\n  ## final names setting\n  standardNames <- reactive({\n    if(input$datype == \"intensity\"){\n\n      out<-   paste(\"rep\",rep(1:input$reps,each = input$chans),\"_\",\n                    rep(paste(\"C\",c(\"ontrol\",0:(input$chans - 2)), sep = \"\"),input$reps),sep = \"\")\n\n      vals$labelNames = setNames(out, out)\n\n    }else{\n      out<-  paste(\"rep\",rep(1:input$reps,each = input$chans),\"_\",\n                   rep(paste(\"C\",0:(input$chans - 1), sep = \"\"),input$reps),sep = \"\")\n      vals$labelNames = setNames(out, out)\n\n    }\n\n    return(out)\n  })\n\n  output$setNames <- renderUI({\n\n    list(\n      h4(\"Change Names\")\n      , selectInput(\"nameToChange\", \"Standard name\"\n                    , names(vals$labelNames))\n      , textInput(\"labelToAdd\", \"Change to\")\n      , actionButton(\"makeLabel\", \"Set label\")\n    )\n\n  })\n\n  observeEvent(input$makeLabel, {\n    vals$labelNames[input$nameToChange] <- input$labelToAdd\n  })\n\n  finalNames<- reactive({\n\n\n    vals$labelNames\n\n\n\n\n  })\n\n\n\n  ##############################################\n\n\n\n  sigConc <- reactive({\n\n    if(input$modtyp == \"sigmoid\"){\n      sort(as.numeric(unlist(strsplit(input$concsig,\",\"))))\n    }else{\n      return(NULL)\n    }\n\n  })\n\n\n  output$concsig <- renderText({\n\n\n    x <- as.numeric(unlist(strsplit(input$concsig,\",\")))\n    if(input$datype== 'intensity'){\n      n<- input$chans - 1\n    }else{\n\n      n <- input$chans*input$reps\n    }\n\n    if(length(x) < n){\n\n        paste0(\"Not enough concentrations, please put \",n,\" concentrations\")\n\n    } else if(length(x) > n){\n\n        paste0(\"Too many concentrations, please put \",n,\" concentrations\")\n\n\n    }else{\n      x<- sort(x)\n      print(c(\"Concentrations:\",x))\n    }\n\n\n  })\n\n\n\n\n  output$selectnames <- renderUI({\n    selectizeInput(\"selectnames\", \"Change Names\", choices = standardNames(),\n                   options = list(maxOptions = input$reps * input$chans))\n  })\n\n\n\n\n  vals <- reactiveValues(\n    labelNames = character()\n  )\n\n  #### LABEL UPLOAD\n\n\n  #### data imported and finalNames is vector of colnames ####\n\n  rReps <- reactive({\n\n    input$reps\n\n  })\n\n  nchans <- reactive({\n    input$reps * input$chans\n\n  })\n\n  ### probably dont need this\n  ### datachange table\n\n\n  ### selectize\n\n  colNamTot<- reactive({\n    reqtemp <- data()\n    req(reqtemp)\n    a2 <- data()\n    colnames(a2)\n  })\n\n  colNamSel<- reactive({\n    a1 <- data()\n    a1 <- colnames(a1)\n    sample(a1,nchans())\n\n  })\n\n\n\n\n\n  indexmatrix <- reactive({\n    reqtemp <- data()\n    req(reqtemp)\n    if(input$reps <= 1){\n      NULL\n    } else {\n      if(input$datype == \"intensity\"){\n        channe <- channels()\n        reps <- input$reps\n        chans <- input$chans - 1\n        ser <- finalNames()\n        ser<- ser[-seq(1,by = input$chans,length.out = input$reps)]\n\n      }else{\n        ser <- finalNames()\n        channe <- channels()\n        reps <- input$reps\n        chans <- input$chans\n\n      }\n\n      combinations <- t(combn(reps,2))\n      combmat<- matrix(rep(as.vector(t(combinations)),chans),ncol = 2,byrow = TRUE)\n\n      # create factor for repeat ...\n\n      name.vec <- 1:(chans*reps)\n      repfac <- rep(1:chans,times = reps)\n      index <- rep(0:(reps-1),each = chans)\n      combfac<- rep(1:(reps),each = chans)\n\n      # total combinations  = chans * nrow()\n      columnindex <- matrix(0 , ncol = 5 , nrow = chans * nrow(combinations) )\n\n      colnames(columnindex) <- c(\"concentration\",\"rep1\",\"rep2\",\"index1\",\"index2\")\n      columnindex[,1] <- rep(1:chans ,each = nrow(combinations))\n\n      columnindex[,2:3]<- combmat\n\n      columnindex\n      # create matrix which will be indexed by first 3 columns of column index\n\n      index.mat <- matrix(name.vec,ncol = reps)\n\n      for(i in 1:nrow(columnindex)){\n\n        columnindex[i,4] <- index.mat[columnindex[i,1],columnindex[i,2]]\n        columnindex[i,5] <- index.mat[columnindex[i,1],columnindex[i,3]]\n\n      }\n\n\n\n\n      dadt <- dataMerge()\n\n      create.names <- rep(\"\", nrow(columnindex))\n\n\n      for( i in 1:nrow(columnindex)){\n        create.names[i] <- paste(ser[columnindex[i,4]], \"vs\", ser[columnindex[i,5]])\n      }\n\n      final.mat <- data.frame(names = create.names,columnindex)\n      final.mat\n      final.mat[!is.na(rowSums(matrix(match(columnindex,channe),ncol=5))),]\n    }\n  })\n\n\n\n  selRemCol <- reactive({\n    reqtemp <- data()\n    req(reqtemp)\n\n    a1<- finalNames()\n    a1<- as.character(a1)\n\n    if(is.null(input$remchan)){\n      0\n    }else{\n      -match(input$remchan,a1)\n\n    }\n\n  })\n\n  channels <- reactive({\n    reqtemp <- data()\n    req(reqtemp)\n\n    if(input$datype == 'intensity'){\n      if(input$reps == 1){\n        1:(input$chans*input$reps -1)\n\n      }else{\n        1:(input$chans*input$reps -2)\n      }\n    }else{\n\n      a1 <- selRemCol()\n      vec <- 1:nchans()\n      if(a1 != 0){\n        vec <- vec[selRemCol()]\n      }\n      vec\n    }\n  })\n\n\n\n  ##### DATA HANDLING #####\n\n  ## Intensities\n\n\n  intData <- reactive({\n\n    if(input$datype == \"intensity\"){\n\n\n      tempdat <- data()\n\n\n      # make matrix of descriptions and accessions to filter by common proteins\n\n      accDesMat<- as.character(tempdat[as.character(tempdat[,input$accession]) == \"\",c(input$accession)])\n\n      if(input$incpd == TRUE){\n        data.merged <- tempdat[,c(input$view_vars, input$accession, input$sequence,input$quality,input$pdofpd)]\n\n      }else{\n        data.merged <- tempdat[,c(input$view_vars, input$accession, input$sequence,input$quality)]\n      }\n\n\n      channelnames <- standardNames()\n      repindex <- rep(1:input$reps,each = input$chans)\n      totfal <- rep(FALSE , (input$chans + 3 ))\n\n      if(input$incpd == TRUE){\n\n        newdf <- cbind(data.merged[,1:input$chans], data.merged[,c(input$accession, input$sequence,input$quality,input$pdofpd)])\n        colnames(newdf) <- c(channelnames[repindex  == 1],\"Accession\",\"Sequence\", \"Quality\",'Kd')\n        newdf <- newdf[!is.na(rowSums(newdf[,1:input$chans])),]\n        newdf <- newdf[newdf$Quality <= 0.05, ]\n        newdf <- data.frame(newdf, outliers = rep(0,length(newdf[,1])), uniquePeps = rep(0,length(newdf[,1])), addedVals = rep(0,length(newdf[,1])),Kd = newdf$Kd)\n\n\n      }else{\n        newdf <- cbind(data.merged[,1:input$chans], data.merged[,c(input$accession, input$sequence,input$quality)])\n        colnames(newdf) <- c(channelnames[repindex  == 1],\"Accession\",\"Sequence\", \"Quality\")\n        newdf <- newdf[!is.na(rowSums(newdf[,1:input$chans])),]\n        newdf <- newdf[newdf$Quality <= 0.05, ]\n      }\n\n      if(input$reps == 2){\n        channelnames <- paste(\"rep\",rep(1:input$reps,each = input$chans),\"_\",\n                              rep(paste(\"C\",c(\"ontrol\",0:(input$chans - 2)), sep = \"\"),input$reps),sep = \"\")\n        newdf2 <- cbind(data.merged[,(input$chans+1):(2*input$chans) ],data.merged[,c(input$accession, input$sequence,input$quality)])\n        colnames(newdf2) <- c(channelnames[repindex  == 2],\"Accession\",\"Sequence\",\"Quality\")\n        newdf2 <- newdf2[!is.na(rowSums(newdf2[,1:input$chans])),]\n        newdf2 <- newdf2[newdf2$Quality <= 0.05, ]\n\n\n\n        newdf <- data.frame(newdf, outliers = rep(0,length(newdf[,1])), uniquePeps = rep(0,length(newdf[,1])), addedVals = rep(0,length(newdf[,1])))\n        newdf2 <- data.frame(newdf2, outliers = rep(0,length(newdf2[,1])), uniquePeps = rep(0,length(newdf2[,1])), addedVals = rep(0,length(newdf2[,1])))\n\n\n        common.proteins <- intersect(unique(newdf$Accession),unique(newdf2$Accession))\n\n        newdf <- newdf[!is.na(match(newdf$Accession,common.proteins)),]\n        newdf2 <- newdf2[!is.na(match(newdf2$Accession,common.proteins)),]\n      }else{\n        common.proteins <- unique(newdf$Accession)\n      }\n\n\n\n      if(input$dorem == \"no\"){\n\n        if(input$reps == 1 & input$modtyp == 'sigmoid'){\n          if(input$incpd == TRUE){\n            prot1 <- unique(newdf$Accession)\n            sumkd <- rep(0,length(prot1))\n            protdf<- newdf[1:length(prot1),colnames(newdf) != \"Sequence\"]\n            for(i in 1:length(prot1)){\n              ## grep for total intensity () includes non unique peps\n              protdf[i,1:input$chans] <- apply(newdf[grep(prot1[i],newdf$Accession),1:input$chans],2,sum,na.rm = TRUE)\n              protdf$Kd[i] <- sum(newdf$Kd[grep(prot1[i],newdf$Accession)],na.rm = TRUE)\n              protdf$Accession[i] <- prot1[i]\n\n              ## use == to get unique peptides per protein per repeat\n              # protdf$uniquePeps[i] <- length(unique(newdf$Sequence[newdf$Accession == prot1[i]]))\n              protdf$uniquePeps[i] <- length(unique(unique(newdf$Sequence[newdf$Accession == prot1[i]])))\n\n            }\n\n            protdf$uniquePeps[grep(\";\",protdf$Accession)] <- 0\n\n            fc1 <- protdf[,1] / protdf[,2:input$chans]\n\n            Kd <- protdf$Kd / protdf[,1]\n\n            fcprotdf <- data.frame(log2(fc1),\n                                   Accession = protdf$Accession,uniquePepr1 = protdf$uniquePeps,\n                                   uniquePepr2 =protdf$uniquePeps, Kd = Kd)\n            fcprotdf<- fcprotdf[!is.na(rowSums(fcprotdf[1:(input$chans - 1 )])),]\n            fcprotdf\n\n          }else{\n\n            prot1 <- unique(newdf$Accession)\n            protdf<- newdf[1:length(prot1),colnames(newdf) != \"Sequence\"]\n\n            for(i in 1:length(prot1)){\n              ## grep for total intensity () includes non unique peps\n              protdf[i,1:input$chans] <- apply(newdf[grep(prot1[i],newdf$Accession),1:input$chans],2,sum,na.rm = TRUE)\n              protdf$Accession[i] <- prot1[i]\n\n              ## use == to get unique peptides per protein per repeat\n              # protdf$uniquePeps[i] <- length(unique(newdf$Sequence[newdf$Accession == prot1[i]]))\n              protdf$uniquePeps[i] <- length(unique(unique(newdf$Sequence[newdf$Accession == prot1[i]])))\n\n            }\n\n            protdf$uniquePeps[grep(\";\",protdf$Accession)] <- 0\n\n            fc1 <- protdf[,1] / protdf[,2:input$chans]\n\n\n            fcprotdf <- data.frame(log2(fc1),\n                                   Accession = protdf$Accession,uniquePepr1 = protdf$uniquePeps,\n                                   uniquePepr2 =protdf$uniquePeps)\n            fcprotdf<- fcprotdf[!is.na(rowSums(fcprotdf[1:(input$chans - 1 )])),]\n            fcprotdf\n\n          }\n\n\n        }else{\n        prot1 <- unique(newdf$Accession)\n        protdf<- newdf[1:length(prot1),colnames(newdf) != \"Sequence\"]\n\n\n        for(i in 1:length(prot1)){\n          ## grep for total intensity () includes non unique peps\n          protdf[i,1:input$chans] <- apply(newdf[grep(prot1[i],newdf$Accession),1:input$chans],2,sum,na.rm = TRUE)\n\n          protdf$Accession[i] <- prot1[i]\n\n          ## use == to get unique peptides per protein per repeat\n          # protdf$uniquePeps[i] <- length(unique(newdf$Sequence[newdf$Accession == prot1[i]]))\n          protdf$uniquePeps[i] <- length(unique(c(unique(newdf$Sequence[newdf$Accession == prot1[i]]),unique(newdf2$Sequence[newdf2$Accession == prot1[i]]))))\n\n        }\n\n        protdf$uniquePeps[grep(\";\",protdf$Accession)] <- 0\n\n\n          prot2 <- unique(newdf2$Accession)\n          ### second data frame\n\n          protdf2<- newdf2[1:length(prot2),colnames(newdf2) != \"Sequence\"]\n\n          for(i in 1:length(prot2)){\n\n            ## grep for total intensity () includes non unique peps\n            protdf2[i,1:input$chans] <- apply(newdf2[grep(prot2[i],newdf2$Accession),1:input$chans],2,median,na.rm = TRUE)\n            protdf2$Accession[i] <- prot2[i]\n\n            ## use == to get unique peptides per protein per repeat\n            protdf2$uniquePeps[i] <- length(unique(newdf2$Sequence[newdf2$Accession == prot2[i]]))\n          }\n\n          protdf2$uniquePeps[grep(\";\",protdf2$Accession)] <- 0\n\n\n          com.prot <- intersect(protdf$Accession,protdf2$Accession)\n\n          fc1 <- protdf[,1] / protdf[,2:input$chans]\n          fc2 <-  protdf2[,1] / protdf2[,2:input$chans]\n\n\n          fcprotdf <- data.frame(log2(fc1[match(com.prot,protdf$Accession),]),\n                                 log2(fc2[match(com.prot,protdf2$Accession),]),\n                                 Accession = com.prot,uniquePepr1 = protdf$uniquePeps[match(com.prot,protdf$Accession)],\n                                 uniquePepr2 =protdf2$uniquePeps[match(com.prot,protdf2$Accession)])\n          fcprotdf<- fcprotdf[!is.na(rowSums(fcprotdf[1:(input$reps*input$chans -2 )])),]\n          fcprotdf\n        }\n\n\n      }else{\n\n        totpepdf <- NULL\n        totpepdf2 <- NULL\n\n        for (z in 1:length(common.proteins)){\n          temp <- newdf[newdf$Accession == common.proteins[z],]\n          temp2 <- newdf2[newdf2$Accession == common.proteins[z],]\n          # first step: check if all peptides are unique ...\n\n          if(all.equal(grep(\";\",temp$Accession),integer(0)) == TRUE){\n\n            uniPeptides1 <- length(unique(temp$Sequence))\n\n          }  else {\n            uniPeptides1 <- length(unique(temp$Sequence[-grep(\";\",temp$Accession)]))\n          }\n\n          if(all.equal(grep(\";\",temp2$Accession),integer(0)) == TRUE){\n\n            uniPeptides2 <- length(unique(temp2$Sequence))\n\n          }else{\n\n            uniPeptides2 <- length(unique(temp2[-grep(\";\",temp2$Accession)]))\n          }\n\n          ## add unique peptide column\n\n          temp$uniquePeps <- uniPeptides1\n          temp2$uniquePeps <- uniPeptides2\n\n\n          tempPep <- intersect(unique(temp$Sequence),unique(temp2$Sequence))\n\n\n          if(all.equal(tempPep, character(0)) == TRUE){\n            next\n          }\n\n          for(i in 1:length(tempPep)){\n\n            if(sum(temp$Sequence == tempPep[i]) != sum(temp2$Sequence == tempPep[i])){\n\n              dr <- peptide.match(temp[temp$Sequence == tempPep[i],],temp2[temp2$Sequence == tempPep[i],],input$chans)\n              dr1 <- dr$dr1\n              dr2 <- dr$dr2\n\n            } else {\n\n              dr1 <- temp[temp$Sequence == tempPep[i],]\n              dr2 <- temp2[temp2$Sequence == tempPep[i],]\n\n\n            }\n\n            tempoindex <- rep(FALSE,nrow(dr1))\n            for(j in 1:nrow(dr1)){\n              percor <- cor.test(log2(as.numeric(dr1[j,1:input$chans])),log2(as.numeric(dr2[j,1:input$chans])))\n              tempoindex[j] <- percor$estimate < input$pearsvar\n            }\n\n            dr1[tempoindex,1:input$chans] <- NA\n            dr2[tempoindex,1:input$chans] <- NA\n\n\n\n            tempReplace <- dr1\n            tempReplace2 <- dr2\n\n\n\n            temp <- temp[temp$Sequence != tempPep[i],]\n            temp <- rbind(temp,tempReplace)\n\n            temp2 <- temp2[temp2$Sequence != tempPep[i],]\n            temp2 <- rbind(temp2,tempReplace2)\n\n          }\n\n          temp<- temp[match(tempPep,temp$Sequence),]\n          temp2<- temp2[match(tempPep,temp2$Sequence),]\n\n          # newdf <- newdf[newdf$Accession != common.proteins[z],]\n          # newdf<- rbind(newdf,temp)\n          totpepdf <- rbind(totpepdf,temp)\n\n          # newdf2 <- newdf2[newdf2$Accession != common.proteins[z],]\n          # newdf2<- rbind(newdf2,temp2)\n          totpepdf2 <- rbind(totpepdf2,temp2)\n        }\n\n\n\n\n        totpepdf<- totpepdf[!is.na(rowSums(totpepdf[,1:input$chans])),]\n        totpepdf2<- totpepdf2[!is.na(rowSums(totpepdf2[,1:input$chans])),]\n\n        totpepdf<- totpepdf[totpepdf$addedVals == 0, ]\n        totpepdf<- totpepdf[totpepdf$addedVals == 0, ]\n\n\n        totpepdf$uniquePeps[grep(';',totpepdf$Accession)] <- 0\n\n\n        ### take sums\n\n        pepframe<- data.frame(totpepdf[1:length(common.proteins),1:input$chans],totpepdf2[1:length(common.proteins),1:input$chans],\n                              Accession = totpepdf$Accession[1:length(common.proteins)], uniquePeps = totpepdf$uniquePeps[1:length(common.proteins)])\n\n        pepsum1 <- pepsum2 <- totpepdf[1:length(common.proteins),]\n        pepsum1 <- pepsum1[,-match(c(\"Sequence\",\"addedVals\", \"Quality\",\"outliers\"),colnames(pepsum1))]\n        pepsum2 <- pepsum2[,-match(c(\"Sequence\",\"addedVals\", \"Quality\",\"outliers\"),colnames(pepsum2))]\n\n        pepsum1$pepNum <- pepsum1$pepNum <- rep(0,length(common.proteins))\n\n\n        colnames(pepsum2)[1:input$chans]<- channelnames[(input$chans+1):(input$chans*input$reps)]\n\n        for(i in 1:length(common.proteins)){\n          pepsum1[i,1:input$chans] <- colSums(totpepdf[grep(common.proteins[i],totpepdf$Accession),1:input$chans])\n          pepsum2[i,1:input$chans] <- colSums(totpepdf2[grep(common.proteins[i],totpepdf2$Accession),1:input$chans])\n\n          pepsum1$pepNum[i] <- nrow(totpepdf[grep(common.proteins[i],totpepdf$Accession),1:input$chans])\n          pepsum2$pepNum[i] <- nrow(totpepdf2[grep(common.proteins[i],totpepdf2$Accession),1:input$chans])\n\n\n          pepsum1$Accession[i]<- pepsum2$Accession[i] <- common.proteins[i]\n          pepsum1$uniquePeps[i]<- totpepdf$uniquePeps[as.logical(match(totpepdf$Accession,common.proteins[i],nomatch = FALSE))][1]\n\n\n\n\n\n          #   pepframe[i, 1:input$chans] <- apply( totpepdf[totpepdf$Accession == common.proteins[i], 1:input$chans],2, sum)\n          # pepframe[i, (input$chans+1):(input$chans*input$reps)] <- apply( totpepdf2[totpepdf2$Accession == common.proteins[i], 1:input$chans],2, sum)\n          #\n          # pepframe$Accession <- common.proteins[i]\n          # pepframe$uniquePeps <- totpepdf$uniquePeps[totpepdf$Accession == common.proteins[i]][1]\n        }\n\n        indexpepsum <- ((rowSums(pepsum1[1:input$chans]) != 0) + ((rowSums(pepsum2[1:input$chans])) != 0)) == 2\n        pepsum1<- pepsum1[indexpepsum, ]\n        pepsum2<- pepsum2[indexpepsum, ]\n\n        # indpepsum2 <- pepsum1$pepNum > 1 | pepsum2$pepNum > 1\n        # pepsum1 <- pepsum1[indpepsum2,]\n        # pepsum2 <- pepsum1[indpepsum2,]\n\n\n        fc1 <- pepsum1[,1] / pepsum1[,2:input$chans]\n        fc2 <- pepsum2[,1] / pepsum2[,2:input$chans]\n\n\n        fcprotdf <- data.frame(log2(fc1),log2(fc2),pepsum1$Accession,uniquePepr1 = pepsum1$uniquePeps,\n                               uniquePepr2 = pepsum2$uniquePeps,num1 =  pepsum1$pepNum, num2 = pepsum2$pepNum )\n\n\n        fcprotdf\n\n      }\n      fcprotdf\n\n    }else{\n      return(NULL)\n    }\n\n\n  })\n\n  ######################################################### isolate removed peptides\n\n  pepdwn <- reactive({\n\n    if(input$intcalc == 0){\n      return(NULL)\n    }else{\n\n\n      tempdat <- data()\n\n\n      # make matrix of descriptions and accessions to filter by common proteins\n\n      accDesMat<- as.character(tempdat[as.character(tempdat[,input$accession]) == \"\",c(input$accession)])\n\n      data.merged <- tempdat[,c(input$view_vars, input$accession, input$sequence,input$quality)]\n\n\n      channelnames <- standardNames()\n      repindex <- rep(1:input$reps,each = input$chans)\n      totfal <- rep(FALSE , (input$chans + 3 ))\n\n\n      newdf <- cbind(data.merged[,1:input$chans], data.merged[,c(input$accession, input$sequence,input$quality)])\n      colnames(newdf) <- c(channelnames[repindex  == 1],\"Accession\",\"Sequence\", \"Quality\")\n      newdf <- newdf[!is.na(rowSums(newdf[,1:input$chans])),]\n      newdf <- newdf[newdf$Quality <= 0.05, ]\n\n\n\n      newdf2 <- cbind(data.merged[,(input$chans+1):(2*input$chans) ],data.merged[,c(input$accession, input$sequence,input$quality)])\n      colnames(newdf2) <- c(channelnames[repindex  == 2],\"Accession\",\"Sequence\",\"Quality\")\n      newdf2 <- newdf2[!is.na(rowSums(newdf2[,1:input$chans])),]\n      newdf2 <- newdf2[newdf2$Quality <= 0.05, ]\n\n\n\n      newdf <- data.frame(newdf, outliers = rep(0,length(newdf[,1])), uniquePeps = rep(0,length(newdf[,1])), addedVals = rep(0,length(newdf[,1])))\n      newdf2 <- data.frame(newdf2, outliers = rep(0,length(newdf2[,1])), uniquePeps = rep(0,length(newdf2[,1])), addedVals = rep(0,length(newdf2[,1])))\n\n\n      common.proteins <- intersect(unique(newdf$Accession),unique(newdf2$Accession))\n\n      newdf <- newdf[!is.na(match(newdf$Accession,common.proteins)),]\n      newdf2 <- newdf2[!is.na(match(newdf2$Accession,common.proteins)),]\n\n\n\n      totpepdf <- NULL\n      totpepdf2 <- NULL\n\n      for (z in 1:length(common.proteins)){\n        temp <- newdf[newdf$Accession == common.proteins[z],]\n        temp2 <- newdf2[newdf2$Accession == common.proteins[z],]\n        # first step: check if all peptides are unique ...\n\n        if(all.equal(grep(\";\",temp$Accession),integer(0)) == TRUE){\n\n          uniPeptides1 <- length(unique(temp$Sequence))\n\n        }  else {\n          uniPeptides1 <- length(unique(temp$Sequence[-grep(\";\",temp$Accession)]))\n        }\n\n        if(all.equal(grep(\";\",temp2$Accession),integer(0)) == TRUE){\n\n          uniPeptides2 <- length(unique(temp2$Sequence))\n\n        }else{\n\n          uniPeptides2 <- length(unique(temp2[-grep(\";\",temp2$Accession)]))\n        }\n\n        ## add unique peptide column\n\n        temp$uniquePeps <- uniPeptides1\n        temp2$uniquePeps <- uniPeptides2\n\n\n        tempPep <- intersect(unique(temp$Sequence),unique(temp2$Sequence))\n\n\n        if(all.equal(tempPep, character(0)) == TRUE){\n          next\n        }\n\n        for(i in 1:length(tempPep)){\n\n          if(sum(temp$Sequence == tempPep[i]) != sum(temp2$Sequence == tempPep[i])){\n\n            dr <- peptide.match(temp[temp$Sequence == tempPep[i],],temp2[temp2$Sequence == tempPep[i],],input$chans)\n            dr1 <- dr$dr1\n            dr2 <- dr$dr2\n\n          } else {\n\n            dr1 <- temp[temp$Sequence == tempPep[i],]\n            dr2 <- temp2[temp2$Sequence == tempPep[i],]\n\n\n          }\n\n          tempoindex <- rep(FALSE,nrow(dr1))\n          for(j in 1:nrow(dr1)){\n            percor <- cor.test(log2(as.numeric(dr1[j,1:input$chans])),log2(as.numeric(dr2[j,1:input$chans])))\n            tempoindex[j] <- percor$estimate < input$pearsvar\n          }\n\n          dr1[tempoindex,1:input$chans] <- NA\n          dr2[tempoindex,1:input$chans] <- NA\n\n\n\n          tempReplace <- dr1\n          tempReplace2 <- dr2\n\n\n\n          temp <- temp[temp$Sequence != tempPep[i],]\n          temp <- rbind(temp,tempReplace)\n\n          temp2 <- temp2[temp2$Sequence != tempPep[i],]\n          temp2 <- rbind(temp2,tempReplace2)\n\n        }\n\n        temp<- temp[match(tempPep,temp$Sequence),]\n        temp2<- temp2[match(tempPep,temp2$Sequence),]\n\n        # newdf <- newdf[newdf$Accession != common.proteins[z],]\n        # newdf<- rbind(newdf,temp)\n        totpepdf <- rbind(totpepdf,temp)\n\n        # newdf2 <- newdf2[newdf2$Accession != common.proteins[z],]\n        # newdf2<- rbind(newdf2,temp2)\n        totpepdf2 <- rbind(totpepdf2,temp2)\n      }\n\n\n\n\n      totpepdf<- totpepdf[!is.na(rowSums(totpepdf[,1:input$chans])),]\n      totpepdf2<- totpepdf2[!is.na(rowSums(totpepdf2[,1:input$chans])),]\n\n      totpepdf<- totpepdf[totpepdf$addedVals == 0, ]\n      totpepdf<- totpepdf[totpepdf$addedVals == 0, ]\n\n\n      totpepdf$uniquePeps[grep(';',totpepdf$Accession)] <- 0\n\n\n      ### take sums\n\n      pepframe<- data.frame(totpepdf[1:length(common.proteins),1:input$chans],totpepdf2[1:length(common.proteins),1:input$chans],\n                            Accession = totpepdf$Accession[1:length(common.proteins)], uniquePeps = totpepdf$uniquePeps[1:length(common.proteins)])\n\n      pepsum1 <- pepsum2 <- totpepdf[1:length(common.proteins),]\n      pepsum1 <- pepsum1[,-match(c(\"Sequence\",\"addedVals\", \"Quality\",\"outliers\"),colnames(pepsum1))]\n      pepsum2 <- pepsum2[,-match(c(\"Sequence\",\"addedVals\", \"Quality\",\"outliers\"),colnames(pepsum2))]\n\n      pepsum1$pepNum <- pepsum1$pepNum <- rep(0,length(common.proteins))\n\n\n      colnames(pepsum2)[1:input$chans]<- channelnames[(input$chans+1):(input$chans*input$reps)]\n\n      for(i in 1:length(common.proteins)){\n        pepsum1[i,1:input$chans] <- colSums(totpepdf[grep(common.proteins[i],totpepdf$Accession),1:input$chans])\n        pepsum2[i,1:input$chans] <- colSums(totpepdf2[grep(common.proteins[i],totpepdf2$Accession),1:input$chans])\n\n        pepsum1$pepNum[i] <- nrow(totpepdf[grep(common.proteins[i],totpepdf$Accession),1:input$chans])\n        pepsum2$pepNum[i] <- nrow(totpepdf2[grep(common.proteins[i],totpepdf2$Accession),1:input$chans])\n\n\n        pepsum1$Accession[i]<- pepsum2$Accession[i] <- common.proteins[i]\n        pepsum1$uniquePeps[i]<- totpepdf$uniquePeps[as.logical(match(totpepdf$Accession,common.proteins[i],nomatch = FALSE))][1]\n\n      }\n\n      indexpepsum <- ((rowSums(pepsum1[1:input$chans]) != 0) + ((rowSums(pepsum2[1:input$chans])) != 0)) == 2\n      pepsum1<- pepsum1[indexpepsum, ]\n      pepsum2<- pepsum2[indexpepsum, ]\n\n      end <- -row.match(newdf[,1:(input$chans+2)],totpepdf[,1:(input$chans+2)])\n      end2 <- -row.match(newdf2[,1:(input$chans+2)],totpepdf2[,1:(input$chans+2)])\n\n      rempep <- newdf[end,]\n      rempep2 <- newdf2[end2,]\n      colnames(rempep)<- paste(\"r1_\",colnames(rempep),sep = '')\n      colnames(rempep2)<- paste(\"r2_\",colnames(rempep2),sep = '')\n\n\n\n      if(nrow(rempep) > nrow(rempep2)){\n\n        finalrempep <- rempep\n        finalrempep[] <- NA\n        finalrempep[1:nrow(rempep2),]<- rempep2\n        finalrempep<- cbind(rempep,finalrempep)\n      }else{\n        finalrempep <- rempep2\n        finalrempep[] <- NA\n        finalrempep[1:nrow(rempep),] <- rempep\n        finalrempep <- cbind(finalrempep,rempep2)\n      }\n      colnames(finalrempep)<- c(paste(\"r1_\",colnames(rempep),sep = ''),paste(\"r2_\",colnames(rempep2),sep = ''))\n      finalrempep\n\n    }\n\n  })\n\n  ## log fold changes\n\n\n  dataMerge <- reactive({\n    # testingkd <- rKd()\n    # print(head(testingkd))\n    inten <- intData()\n\n    if(input$datype != \"intensity\"){\n\n      if(input$modtyp == \"sigmoid\"){\n\n        data_orig2 <- data()\n\n        ## if user has specified accession & Description\n        if(input$toacc == FALSE){\n          pattern<-\"GN=(\\\\S+)\"\n          g_fromD1<-str_extract(data_orig2$Description,pattern)\n          gID_D1a<-str_split_fixed(g_fromD1,\"GN=\",n=2)\n          gID_D1a<-as.vector(gID_D1a[,2])\n          gID_D1<-as.matrix(replace(gID_D1a,gID_D1a==\"\",\"NA\"))\n          #Addition of the gene ID column\n          data_orig2[\"geneID\"]<- (gID_D1)\n        }else{\n          if(input$genefile == FALSE){\n            tempacc <- data_orig2[,input$accession]\n            data_orig2 <- data_orig2[,(-input$accession)]\n            data_orig2$Accession <- tempacc\n            uniGene <- uniprotGene()\n            # uniGene$Gene.names <- gsub(' .*','',uniGene$Gene.names)\n            uniGene$Gene.names[uniGene$Gene.names == '']<- NA\n            GeneID <- uniGene$Gene.names[match(data_orig2$Accession,uniGene$Entry)]\n            GeneID <- make.names(GeneID,unique = TRUE)\n\n            data_orig2$geneID <- GeneID\n          }else{\n\n            tempacc <- data_orig2[,input$accession]\n            data_orig2 <- data_orig2[,(-input$accession)]\n            data_orig2$Accession <- tempacc\n\n            uniGene <- uploadGene()\n            GeneID <- uniGene$Gene.names[match(data_orig2$Accession,uniGene$Entry)]\n            GeneID <- make.names(GeneID,unique = TRUE)\n\n            data_orig2$geneID <- GeneID\n\n          }\n        }\n\n        if(input$incpd == TRUE){\n\n          if(input$toacc == FALSE){\n            data.merged<-data.frame(data_orig2[,input$view_vars],\n\n                                    data_orig2$Accession, data_orig2$geneID,\n                                    data_orig2$X..Unique.Peptides,data_orig2[,input$pdofpd])\n          }else{\n            data.merged<-data.frame(data_orig2[,input$view_vars],\n\n                                    data_orig2$Accession, data_orig2$geneID,\n                                    data_orig2[,input$unipeps],data_orig2[,input$pdofpd])\n          }\n          final.Names <- finalNames()\n          colnames(data.merged)<- c(final.Names,\n                                    \"Accession\", \"GeneID\",\"UniquePeps\",'Kd')\n\n\n          tmp<-data.merged[,1:input$chans]\n          tf <- as.data.frame(lapply(tmp, function(x) (is.na(x))))\n          countsNAs<-as.data.frame(apply(tf,1,function(x)table(x)[\"TRUE\"]))\n          n_of_miss<-as.data.frame(as.numeric(str_replace_all(as.list(countsNAs[,1]),\"NA\",0)))\n          data.merged <- data.frame(data.merged,n_of_miss)\n          colnames(data.merged)<-c( final.Names,\n                                    \"Accession\", \"GeneID\",\"UniquePeps\",'Kd', \"MissingVal\")\n          #\n          missing_val <- 0\n          #\n          data.merged<- as.data.frame(data.merged[data.merged$MissingVal <= missing_val, ])\n          #\n          # #Specify the number of missing points.For zero missing point  is ==0\n          #\n          # #filiter for 2 unique peptides\n          data.merged <- data.merged[data.merged$UniquePeps > 1, ]\n          #\n          #\n          if(input$normalize == 'loess' ){\n            data.merged <- data.frame((normalize.loess(2^(data.merged[,channels()]))),\n                                      Accession=data.merged$Accession,\n                                      GeneID=data.merged$GeneID,\n                                      UniquePeps=data.merged$UniquePeps,\n                                      Kd = 1 / data.merged$Kd,\n                                      MissingVal=data.merged$MissingVal)\n          }else if(input$normalize == 'median'){\n            data.merged <- data.frame(((2^(data.merged[,channels()]))) /\n                                        apply((2^(data.merged[,channels()])),2,median),\n                                      Accession=data.merged$Accession,\n                                      GeneID=data.merged$GeneID,\n                                      UniquePeps=data.merged$UniquePeps,\n                                      Kd = 1 / data.merged$Kd,\n                                      MissingVal=data.merged$MissingVal)\n          }else{\n            data.merged <- data.frame(((2^(data.merged[,channels()]))),\n                                      Accession=data.merged$Accession,\n                                      GeneID=data.merged$GeneID,\n                                      UniquePeps=data.merged$UniquePeps,\n                                      Kd = 1 / data.merged$Kd,\n                                      MissingVal=data.merged$MissingVal)\n          }\n\n\n                data.merged\n\n        } else {\n          if(input$toacc == FALSE){\n            data.merged<-data.frame(data_orig2[,input$view_vars],\n\n                                    data_orig2$Accession, data_orig2$geneID,\n                                    data_orig2$X..Unique.Peptides)\n\n          }else{\n            data.merged<-data.frame(data_orig2[,input$view_vars],\n\n                                    data_orig2$Accession, data_orig2$geneID,\n                                    data_orig2[,input$unipeps])\n          }\n          final.Names <- finalNames()\n\n          colnames(data.merged)<- c(final.Names,\n                                    \"Accession\", \"GeneID\",\"UniquePeps\")\n\n\n          tmp<-data.merged[,1:input$chans]\n          tf <- as.data.frame(lapply(tmp, function(x) (is.na(x))))\n          countsNAs<-as.data.frame(apply(tf,1,function(x)table(x)[\"TRUE\"]))\n          n_of_miss<-as.data.frame(as.numeric(str_replace_all(as.list(countsNAs[,1]),\"NA\",0)))\n          data.merged <- data.frame(data.merged,n_of_miss)\n          colnames(data.merged)<-c( final.Names,\n                                    \"Accession\", \"GeneID\",\"UniquePeps\",\"MissingVal\")\n          #\n          missing_val <- 0\n          #\n          data.merged<- as.data.frame(data.merged[data.merged$MissingVal <= missing_val, ])\n          #\n          # #Specify the number of missing points.For zero missing point  is ==0\n          #\n          # #filiter for 2 unique peptides\n          data.merged <- data.merged[data.merged$UniquePeps > 1, ]\n          #\n          #\n          if(input$normalize == 'loess'){\n            data.merged <- data.frame((normalize.loess(2^(data.merged[,channels()]))),\n                                      Accession=data.merged$Accession,\n                                      GeneID=data.merged$GeneID,\n                                      UniquePeps=data.merged$UniquePeps,\n                                      MissingVal=data.merged$MissingVal)\n\n          }else if (input$normalize == 'median'){\n            data.merged <- data.frame(((2^(data.merged[,channels()])) /\n                                         apply((2^(data.merged[,channels()])),2,median)),\n                                      Accession=data.merged$Accession,\n                                      GeneID=data.merged$GeneID,\n                                      UniquePeps=data.merged$UniquePeps,\n                                      MissingVal=data.merged$MissingVal)\n          }else{\n            data.merged <- data.frame((2^(data.merged[,channels()])),\n                                      Accession=data.merged$Accession,\n                                      GeneID=data.merged$GeneID,\n                                      UniquePeps=data.merged$UniquePeps,\n                                      MissingVal=data.merged$MissingVal)\n          }\n\n          data.merged\n        }\n\n      } else {\n        tempdat <- data()\n        temp<- channels()\n        nvec <- length(temp)\n\n        data.merged <- tempdat[,input$view_vars]\n        colnames(data.merged) <- finalNames()\n\n        data.names<- c(input$view_vars,\"Accession\", \"GeneID\",\"UniquePeps\",\"MissingVal\")\n\n        if(input$datype == \"FC\"){\n          data.merged[,temp] <- log2(data.merged[,temp])\n        }\n        #tidy below !!\n\n        if(input$toacc == FALSE){\n\n\n          pattern<-\"GN=(\\\\S+)\"\n          g_fromD1<-str_extract(tempdat$Description,pattern)\n          gID_D1a<-str_split_fixed(g_fromD1,\"GN=\",n=2)\n          gID_D1a<-as.vector(gID_D1a[,2])\n          gID_D1<-as.matrix(replace(gID_D1a,gID_D1a==\"\",\"NA\"))\n\n          Accession <- tempdat$Accession\n          UniquePeps <- MissingVal<- tempdat[,grep(\"Unique\",colnames(tempdat))]\n          data.merged <- cbind(data.merged,Accession, GeneID = gID_D1,UniquePeps,MissingVal)\n\n        } else {\n\n          tempdat$Accession <- tempdat[,input$accession]\n          if(input$genefile == FALSE){\n\n            uniGene <- uniprotGene()\n            # uniGene<- as.data.frame(uniGene,stringsAsFactors = FALSE)\n            # uniGene$Gene.names <- gsub(' .*','',uniGene$Gene.names)\n            print(head(uniGene))\n          } else{\n            uniGene <- uploadGene()\n            colnames(uniGene)[1:2] <- c('Entry','Gene.names')\n          }\n          # uniGene$Gene.names[uniGene$Gene.names == '']<- NA\n          GeneID <- uniGene$Gene.names[match(tempdat$Accession,uniGene$Entry)]\n          GeneID <- make.names(GeneID,unique = TRUE)\n         print(GeneID)\n\n          Accession <- tempdat$Accession\n          UniquePeps <- MissingVal<- tempdat[,input$unipeps]\n\n          # data_orig2$geneID <- GeneID\n          data.merged <- cbind(data.merged,Accession, GeneID = GeneID,UniquePeps,MissingVal)\n          print(head(data.merged))\n        }\n\n\n\n        missing<- rowSums(is.na(data.merged[,channels()]))\n\n        missing_val <- 0\n        data.merged$MissingVal <- missing\n\n        ## subset by missing\n        data.merged <- data.merged[data.merged$MissingVal <= missing_val, ]\n        data.merged<- as.data.frame(data.merged[data.merged$MissingVal <= missing_val, ])\n\n        data.merged <- data.merged[data.merged$UniquePeps > 1, ]\n        #\n        #\n        if(input$normalize == 'loess'){\n          data.merged <- data.frame(log2(normalize.loess(2^(data.merged[,channels()]))),\n                                    Accession=data.merged$Accession,\n                                    GeneID=data.merged$GeneID,\n                                    UniquePeps=data.merged$UniquePeps,\n                                    MissingVal=data.merged$MissingVal)\n\n        }else if(input$normalize == 'median'){\n          data.merged <- data.frame(log2(((2^(data.merged[,channels()])) / apply((2^(data.merged[,channels()])),2,median))),\n                                    Accession=data.merged$Accession,\n                                    GeneID=data.merged$GeneID,\n                                    UniquePeps=data.merged$UniquePeps,\n                                    MissingVal=data.merged$MissingVal)\n        }else{\n          data.merged <- data.frame(log2((2^(data.merged[,channels()]))),\n                                    Accession=data.merged$Accession,\n                                    GeneID=data.merged$GeneID,\n                                    UniquePeps=data.merged$UniquePeps,\n                                    MissingVal=data.merged$MissingVal)\n        }\n\n        data.merged\n        ## filter for 2 unique peptide\n      }\n\n    } else {\n\n      ### intensities to protein done.. here no description so we need toi use accession and intermine\n\n      tempdat <- inten\n\n      if(input$genefile == FALSE){\n\n        uniGene <- uniprotGene()\n        # uniGene$Gene.names <- gsub(' .*','',uniGene$Gene.names)\n      }else{\n        uniGene <- uploadGene()\n        colnames(uniGene) <- c('Entry','Gene.names')\n      }\n\n      if(input$dorem =='yes'){\n\n        Accession <- tempdat$pepsum1.Accession\n      }else{\n        Accession <- tempdat$Accession\n      }\n      uniGene$Gene.names[uniGene$Gene.names == '']<- NA\n      GeneID <- uniGene$Gene.names[match(Accession,uniGene$Entry)]\n      GeneID <- make.names(GeneID,unique = TRUE)\n\n      tempdat$GeneID <- GeneID\n\n      UniquePeps <- tempdat$uniquePepr1\n\n      if(input$reps == 1){\n\n        data.merged <- tempdat\n        final.Names <- paste0('rep1_C',0:(input$chans - 2))\n        if(input$incpd == TRUE){\n\n          data.merged <- data.frame(data.merged[,1:(input$chans -1 )], Accession = data.merged$Accession,\n                                    GeneID = data.merged$GeneID, UniquePeps = data.merged$uniquePepr1, Kd = data.merged$Kd)\n          colnames(data.merged)<- c(final.Names,\n                                    \"Accession\", \"GeneID\",\"UniquePeps\", 'Kd')\n\n          tmp<-data.merged[,1:(input$chans -1 )]\n          tf <- as.data.frame(lapply(tmp, function(x) (is.na(x))))\n          countsNAs<-as.data.frame(apply(tf,1,function(x)table(x)[\"TRUE\"]))\n          n_of_miss<-as.data.frame(as.numeric(str_replace_all(as.list(countsNAs[,1]),\"NA\",0)))\n          data.merged <- data.frame(data.merged,n_of_miss)\n          colnames(data.merged)<-c( final.Names,\n                                    \"Accession\", \"GeneID\",\"UniquePeps\",'Kd',\"MissingVal\")\n          #\n          missing_val <- 0\n          #\n          data.merged<- as.data.frame(data.merged[data.merged$MissingVal <= missing_val, ])\n          #\n          # #Specify the number of missing points.For zero missing point  is ==0\n          #\n          # #filiter for 2 unique peptides\n          data.merged <- data.merged[data.merged$UniquePeps > 1, ]\n          #\n          #\n          if(input$normalize == 'loess'){\n            data.merged <- data.frame((normalize.loess(2^(data.merged[,1:(input$chans -1)]))),\n                                      Accession=data.merged$Accession,\n                                      GeneID=data.merged$GeneID,\n                                      UniquePeps=data.merged$UniquePeps,\n                                      Kd = data.merged$Kd\n            )\n          }else if(input$normalize == 'median'){\n            data.merged <- data.frame(((2^(data.merged[,1:(input$chans -1)]))/ (apply((2^(data.merged[,1:(input$chans -1)])),2,median))),\n                                      Accession=data.merged$Accession,\n                                      GeneID=data.merged$GeneID,\n                                      UniquePeps=data.merged$UniquePeps,\n                                      Kd = data.merged$Kd\n            )\n          }else{\n            data.merged <- data.frame((2^(data.merged[,1:(input$chans -1)])),\n            Accession=data.merged$Accession,\n            GeneID=data.merged$GeneID,\n            UniquePeps=data.merged$UniquePeps,\n            Kd = data.merged$Kd\n            )\n          }\n\n\n\n\n          data.merged\n\n        } else {\n\n          data.merged <- data.frame(data.merged[,1:(input$chans -1 )], Accession = data.merged$Accession,\n                                    GeneID = data.merged$GeneID, UniquePeps = data.merged$uniquePepr1)\n          colnames(data.merged)<- c(final.Names,\n                                    \"Accession\", \"GeneID\",\"UniquePeps\")\n\n\n          tmp<-data.merged[,1:(input$chans -1 )]\n          tf <- as.data.frame(lapply(tmp, function(x) (is.na(x))))\n          countsNAs<-as.data.frame(apply(tf,1,function(x)table(x)[\"TRUE\"]))\n          n_of_miss<-as.data.frame(as.numeric(str_replace_all(as.list(countsNAs[,1]),\"NA\",0)))\n          data.merged <- data.frame(data.merged,n_of_miss)\n          colnames(data.merged)<-c( final.Names,\n                                    \"Accession\", \"GeneID\",\"UniquePeps\",\"MissingVal\")\n          #\n          missing_val <- 0\n          #\n          data.merged<- as.data.frame(data.merged[data.merged$MissingVal <= missing_val, ])\n          #\n          # #Specify the number of missing points.For zero missing point  is ==0\n          #\n          # #filiter for 2 unique peptides\n          data.merged <- data.merged[data.merged$UniquePeps > 1, ]\n          #\n          #\n          if(input$normalize == 'loess'){\n            data.merged <- data.frame((normalize.loess(2^(data.merged[,1:(input$chans -1)]))),\n                                      Accession=data.merged$Accession,\n                                      GeneID=data.merged$GeneID,\n                                      UniquePeps=data.merged$UniquePeps)\n          }else if(input$normalize == 'median'){\n            data.merged <- data.frame(((2^(data.merged[,1:(input$chans -1)])) /\n                                         apply((2^(data.merged[,1:(input$chans -1)])),2,median)),\n                                      Accession=data.merged$Accession,\n                                      GeneID=data.merged$GeneID,\n                                      UniquePeps=data.merged$UniquePeps)\n          }else{\n            data.merged <- data.frame(((2^(data.merged[,1:(input$chans -1)]))),\n                                      Accession=data.merged$Accession,\n                                      GeneID=data.merged$GeneID,\n                                      UniquePeps=data.merged$UniquePeps)\n          }\n\n\n          data.merged\n        }\n\n      } else{\n\n        data.merged <- tempdat[,1:(input$chans*input$reps - 2)]\n        data.merged <- tempdat[,1:(input$chans*input$reps - 2)]\n        if( input$dorem == 'no'){\n          Accession <- tempdat$Accession\n          MissingVal <- UniquePeps\n          data.merged <- cbind(data.merged,Accession, GeneID = GeneID,UniquePeps,MissingVal)\n\n          data.merged <- data.merged[!is.na(rowSums(data.merged[,1:(input$chans*input$reps -2)])),]\n          data.merged <- data.merged[data.merged$UniquePeps > 1, ]\n\n          if(input$normalize == 'loess'){\n            data.merged <- data.frame((log2(normalize.loess(2^(data.merged[,1:(input$chans*input$reps - 2)])))),\n                                      Accession=data.merged$Accession,\n                                      GeneID=data.merged$GeneID,\n                                      UniquePeps=data.merged$UniquePeps)\n          }else if(input$normalize == 'median'){\n            data.merged <- data.frame(log2(((2^(data.merged[,1:(input$chans*input$reps - 2)])) /\n                                               apply((2^(data.merged[,1:(input$chans*input$reps - 2)])),2,median))),\n                                      Accession=data.merged$Accession,\n                                      GeneID=data.merged$GeneID,\n                                      UniquePeps=data.merged$UniquePeps)\n          }else{\n            data.merged <- data.frame((log2((2^(data.merged[,1:(input$chans*input$reps - 2)])))),\n                                      Accession=data.merged$Accession,\n                                      GeneID=data.merged$GeneID,\n                                      UniquePeps=data.merged$UniquePeps)\n          }\n\n\n          data.merged <- data.merged[!is.na(rowSums(data.merged[,1:(input$chans*input$reps -2)])),]\n          data.merged\n        }else{\n\n          Accession <- tempdat$pepsum1.Accession\n          data.merged <- cbind(data.merged,Accession, GeneID = GeneID,UniquePeps, num1 = tempdat$num1, num2 = tempdat$num2)\n\n\n          data.merged <- data.merged[!is.na(rowSums(data.merged[,1:(input$chans*input$reps -2)])),]\n          data.merged <- data.merged[data.merged$UniquePeps > 1, ]\n          if(input$normalize == 'loess'){\n            data.merged <- data.frame((log2(normalize.loess(2^(data.merged[,1:(input$chans*input$reps - 2)])))),\n                                      Accession=data.merged$Accession,\n                                      GeneID=data.merged$GeneID,\n                                      UniquePeps=data.merged$UniquePeps, num1 = data.merged$num1, num2 = data.merged$num2)\n          }else if(input$normalize == 'median'){\n            data.merged <- data.frame((log2(((2^(data.merged[,1:(input$chans*input$reps - 2)])) /\n                                               apply((2^(data.merged[,1:(input$chans*input$reps - 2)])), 2, median)))),\n                                      Accession=data.merged$Accession,\n                                      GeneID=data.merged$GeneID,\n                                      UniquePeps=data.merged$UniquePeps, num1 = data.merged$num1, num2 = data.merged$num2)\n          }else{\n            data.merged <- data.frame((log2((2^(data.merged[,1:(input$chans*input$reps - 2)])))),\n                                      Accession=data.merged$Accession,\n                                      GeneID=data.merged$GeneID,\n                                      UniquePeps=data.merged$UniquePeps, num1 = data.merged$num1, num2 = data.merged$num2)\n          }\n\n          data.merged <- data.merged[data.merged$num1 > 1 | data.merged$num2 > 1 , ]\n          data.merged <- data.merged[!is.na(rowSums(data.merged[,1:(input$chans*input$reps -2)])),]\n          data.merged\n        }\n\n              }\n\n\n    }\n\n\n    data.merged\n  })\n\n  sigFinalNames <- reactive({\n    paste0(\"C_\",1:input$chans)\n  })\n\n  sigPredNames <- reactive({\n    paste0(\"predX\",1:input$chans)\n  })\n\n  dataMerge2 <- reactive({\n    nvec <- channels()\n    nvec <- length(nvec)\n    data.merged <- dataMerge()\n\n    if(input$modtyp == \"sigmoid\"){\n      if(input$datype == 'intensity'){\n\n\n        conc <- sigConc()\n        if(input$incpd == TRUE){\n\n          final.Names <- paste0('rep1_C',0:(input$chans - 2 ))\n          pred.names <- paste0('predX',1:(input$chans -1))\n          colnames(data.merged[,1:(input$chans -1)]) <- final.Names\n          data_merged_positives<- data.merged\n          # na.omit(data.merged[data.merged[,1:input$chans] >= 1,])\n\n          data_merged_positives2<-( (1/data_merged_positives[,1:(input$chans -1 )]))*100\n          Reps_FC<-data.frame(data_merged_positives2 ,\n                              Accession =  data_merged_positives$Accession,GeneID = data_merged_positives$GeneID,\n                              UniquePeps = data_merged_positives$UniquePeps, depletionConstant = data_merged_positives$Kd\n          )\n\n\n          ryegrass.m1<- vector(mode = \"list\",length = nrow(Reps_FC))\n          pvals<-list()\n          stderr<-list()\n          model_pred<-list()\n          coeff_predicted<-list()\n          for(i in 1:nrow(Reps_FC)){\n            #print(i)\n\n            #nrow(full_df_2)\n            #maxIt and relTol to be user defined\n            ryegrass.m1[[i]]<-try(drm(as.numeric(Reps_FC[i,1:(input$chans - 1 )]) ~ as.numeric(conc),\n                                      na.action = na.omit,\n                                      control = drmc(constr = FALSE, errorm = FALSE, noMessage = TRUE, maxIt = 1000, relTol = 1e-06),\n                                      fct = LL.4(fixed=c(NA, NA, NA, NA), #see note @top this file\n                                                 names = c(\"Slope\", \"Lower Limit\", \"Upper Limit\", \"RB50\"))),silent = T)\n\n          }\n\n          failed_sigm=0\n          for(i in 1:length(ryegrass.m1)){\n            #print(i)\n            #checking_val if FALSE  the model has failed to calculate the pval\n            checking_val<-try(is.numeric(coefficients(ryegrass.m1[[i]])[[\"Slope:(Intercept)\"]]),silent = T)\n\n            if(checking_val==\"TRUE\"){\n              #print(checking_val)\n              pvals[[i]]<-t(as.data.frame(summary(ryegrass.m1[[i]])$coefficients[13:16]))\n              colnames(pvals[[i]])<-c(\"SlopePval\", \"Lower_LimitPval\", \"Upper_LimitPval\", \"RB50Pval\")\n              coeff_predicted[[i]]<-t(data.frame(coefficients(ryegrass.m1[[i]])))\n              colnames(coeff_predicted[[i]])<-c(\"SlopeCoef\", \"Lower_LimitCoef\", \"Upper_LimitCoef\",\"RB50Coef\")\n              stderr[[i]]<-t(as.data.frame(summary(ryegrass.m1[[i]])$coefficients[5:8]))\n              colnames(stderr[[i]])<-c(\"SlopeErr\", \"Lower_LimitErr\", \"Upper_LimitErr\",\"RB50Err\")\n\n              model_pred[[i]]<-predict(ryegrass.m1[[i]])\n            }else{\n              failed_sigm=failed_sigm+1\n\n              fit <- lm(as.numeric(Reps_FC[i,1:(input$chans -1)]) ~ poly(log10(conc),2 ))\n              #extract the pval\n              pval<-as.numeric(summary(fit)$coefficients[,4] )\n              pvals[[i]]<- t(as.data.frame(c(pval,\"lm-fit:intercept.slope.quadratic\") ))\n              colnames(pvals[[i]])<-c(\"SlopePval\", \"Lower_LimitPval\", \"Upper_LimitPval\",\"RB50Pval\")\n              stderr[[i]]<- data.frame(NA,NA,NA,NA)\n              colnames(stderr[[i]])<-c(\"SlopeErr\", \"Lower_LimitErr\", \"Upper_LimitErr\",\"RB50Err\")\n              coeff_predicted[[i]]<-data.frame(NA,NA,NA,NA)\n              colnames(coeff_predicted[[i]])<-c(\"SlopeCoef\", \"Lower_LimitCoef\", \"Upper_LimitCoef\",\"RB50Coef\")\n              model_pred[[i]]<- as.numeric(fitted(fit))\n            } #just adding NAs for the times the model failed\n          }\n\n\n          modelsReps<-data.frame(\n            do.call(rbind.data.frame,lapply(model_pred,function(x) as.numeric(x))),\n            Reps_FC$GeneID,\n            do.call(rbind.data.frame,lapply(pvals,function(x) x) ),\n            do.call(rbind.data.frame,lapply(coeff_predicted,function(x) x)) ,\n            do.call(rbind.data.frame,lapply(stderr,function(x) x) )\n          )\n          colnames(modelsReps)<-c(pred.names,\"GeneID\",\n                                  \"SlopePval\", \"Lower_LimitPval\",\"Upper_LimitPval\", \"RB50Pval\",\n                                  \"SlopeCoef\", \"Lower_LimitCoef\",\"Upper_LimitCoef\", \"RB50Coef\",\n                                  \"SlopeErr\", \"Lower_LimitErr\",\"Upper_LimitErr\", \"RB50Err\"\n          )\n\n          data_merged_2 <-merge.data.frame(modelsReps,Reps_FC,by = 'GeneID')\n\n\n          data_merged_2<-data.frame(data_merged_2,\"Top_minus_min\"=data_merged_2$predX1-data_merged_2[,paste(\"predX\",(input$chans-1),sep = \"\")])\n\n          crap <- crapome()\n          #\n          tempcrap <- crap$Gene\n          tempcrap<- crap$percentagePresent[match(data_merged_2$GeneID,crap$Gene)]\n          data_merged_2 <- data.frame(data_merged_2, CRAPomePercent = tempcrap)\n\n          proteome<-as.vector(toupper(data_merged_2$GeneID))\n          mykinases <- intersect(proteome,kinome)\n\n          if(!is.null(input$venninp)){\n           myvenninp <- uploadVenn()\n           uploadsInt <- intersect(proteome,myvenninp)\n\n           myvenvec <- match(proteome, uploadsInt, nomatch = NA)\n\n           ## now combine with my kin vec\n\n           mykinvec <- match(proteome,mykinases, nomatch = NA)\n           mykinvec[!is.na(mykinvec) & !is.na(myvenvec)] <- 'KINASE + UPLOAD'\n           mykinvec[!is.na(mykinvec) & is.na(myvenvec)] <- 'KINASE'\n           mykinvec[is.na(mykinvec) & !is.na(myvenvec)] <- 'UPLOAD'\n           print(mykinvec)\n\n          } else {\n\n            mykinvec <- match(proteome,mykinases, nomatch = NA)\n            mykinvec[!is.na(mykinvec)]<- 'KINASE'\n\n          }\n\n          data_merged_2<- data.frame(data_merged_2, correctedRB50 = (data_merged_2$RB50Coef*data_merged_2$depletionConstant),Kinase = mykinvec)\n          data_merged_2\n\n        } else {\n\n          final.Names <- paste0('rep1_C',0:(input$chans - 2 ))\n          pred.names <- paste0('predX',1:(input$chans -1))\n          colnames(data.merged[,1:(input$chans -1)]) <- final.Names\n          data_merged_positives<- data.merged\n          # na.omit(data.merged[data.merged[,1:input$chans] >= 1,])\n\n          data_merged_positives2<-( (1/data_merged_positives[,1:(input$chans -1 )]))*100\n          Reps_FC<-data.frame(data_merged_positives2 ,\n                              Accession =  data_merged_positives$Accession,GeneID = data_merged_positives$GeneID,\n                              UniquePeps = data_merged_positives$UniquePeps\n          )\n\n\n          ryegrass.m1<- vector(mode = \"list\",length = nrow(Reps_FC))\n          pvals<-list()\n          stderr<-list()\n          model_pred<-list()\n          coeff_predicted<-list()\n          for(i in 1:nrow(Reps_FC)){\n            #print(i)\n\n            #nrow(full_df_2)\n            #maxIt and relTol to be user defined\n            ryegrass.m1[[i]]<-try(drm(as.numeric(Reps_FC[i,1:(input$chans - 1 )]) ~ as.numeric(conc),\n                                      na.action = na.omit,\n                                      control = drmc(constr = FALSE, errorm = FALSE, noMessage = TRUE, maxIt = 1000, relTol = 1e-06),\n                                      fct = LL.4(fixed=c(NA, NA, NA, NA), #see note @top this file\n                                                 names = c(\"Slope\", \"Lower Limit\", \"Upper Limit\", \"RB50\"))),silent = T)\n\n          }\n\n          failed_sigm=0\n          for(i in 1:length(ryegrass.m1)){\n            #print(i)\n            #checking_val if FALSE  the model has failed to calculate the pval\n            checking_val<-try(is.numeric(coefficients(ryegrass.m1[[i]])[[\"Slope:(Intercept)\"]]),silent = T)\n\n            if(checking_val==\"TRUE\"){\n              #print(checking_val)\n              pvals[[i]]<-t(as.data.frame(summary(ryegrass.m1[[i]])$coefficients[13:16]))\n              colnames(pvals[[i]])<-c(\"SlopePval\", \"Lower_LimitPval\", \"Upper_LimitPval\", \"RB50Pval\")\n              coeff_predicted[[i]]<-t(data.frame(coefficients(ryegrass.m1[[i]])))\n              colnames(coeff_predicted[[i]])<-c(\"SlopeCoef\", \"Lower_LimitCoef\", \"Upper_LimitCoef\",\"RB50Coef\")\n              stderr[[i]]<-t(as.data.frame(summary(ryegrass.m1[[i]])$coefficients[5:8]))\n              colnames(stderr[[i]])<-c(\"SlopeErr\", \"Lower_LimitErr\", \"Upper_LimitErr\",\"RB50Err\")\n\n              model_pred[[i]]<-predict(ryegrass.m1[[i]])\n            }else{\n              failed_sigm=failed_sigm+1\n\n              fit <- lm(as.numeric(Reps_FC[i,1:(input$chans -1)]) ~ poly(log10(conc),2 ))\n              #extract the pval\n              pval<-as.numeric(summary(fit)$coefficients[,4] )\n              pvals[[i]]<- t(as.data.frame(c(pval,\"lm-fit:intercept.slope.quadratic\") ))\n              colnames(pvals[[i]])<-c(\"SlopePval\", \"Lower_LimitPval\", \"Upper_LimitPval\",\"RB50Pval\")\n              stderr[[i]]<- data.frame(NA,NA,NA,NA)\n              colnames(stderr[[i]])<-c(\"SlopeErr\", \"Lower_LimitErr\", \"Upper_LimitErr\",\"RB50Err\")\n              coeff_predicted[[i]]<-data.frame(NA,NA,NA,NA)\n              colnames(coeff_predicted[[i]])<-c(\"SlopeCoef\", \"Lower_LimitCoef\", \"Upper_LimitCoef\",\"RB50Coef\")\n              model_pred[[i]]<- as.numeric(fitted(fit))\n            } #just adding NAs for the times the model failed\n          }\n\n\n          modelsReps<-data.frame(\n            do.call(rbind.data.frame,lapply(model_pred,function(x) as.numeric(x))),\n            Reps_FC$GeneID,\n            do.call(rbind.data.frame,lapply(pvals,function(x) x) ),\n            do.call(rbind.data.frame,lapply(coeff_predicted,function(x) x)) ,\n            do.call(rbind.data.frame,lapply(stderr,function(x) x) )\n          )\n          colnames(modelsReps)<-c(pred.names,\"GeneID\",\n                                  \"SlopePval\", \"Lower_LimitPval\",\"Upper_LimitPval\", \"RB50Pval\",\n                                  \"SlopeCoef\", \"Lower_LimitCoef\",\"Upper_LimitCoef\", \"RB50Coef\",\n                                  \"SlopeErr\", \"Lower_LimitErr\",\"Upper_LimitErr\", \"RB50Err\"\n          )\n\n          data_merged_2 <-merge.data.frame(modelsReps,Reps_FC,by = 'GeneID')\n\n\n          data_merged_2<-data.frame(data_merged_2,\"Top_minus_min\"=data_merged_2$predX1-data_merged_2[,paste(\"predX\",(input$chans-1),sep = \"\")])\n\n          ## crapome integration\n\n          crap <- crapome()\n          #\n          tempcrap <- crap$Gene\n          tempcrap<- crap$percentagePresent[match(data_merged_2$GeneID,crap$Gene)]\n          data_merged_2 <- data.frame(data_merged_2, CRAPomePercent = tempcrap)\n\n          proteome<-as.vector(toupper(data_merged_2$GeneID))\n          mykinases <- intersect(proteome,kinome)\n\n          if(!is.null(input$venninp)){\n            myvenninp <- uploadVenn()\n            uploadsInt <- intersect(proteome,myvenninp)\n\n            myvenvec <- match(proteome, uploadsInt, nomatch = NA)\n\n            ## now combine with my kin vec\n\n            mykinvec <- match(proteome,mykinases, nomatch = NA)\n            mykinvec[!is.na(mykinvec) & !is.na(myvenvec)] <- 'KINASE + UPLOAD'\n            mykinvec[!is.na(mykinvec) & is.na(myvenvec)] <- 'KINASE'\n            mykinvec[is.na(mykinvec) & !is.na(myvenvec)] <- 'UPLOAD'\n            print(mykinvec)\n\n          } else {\n\n            mykinvec <- match(proteome,mykinases, nomatch = NA)\n            mykinvec[!is.na(mykinvec)]<- 'KINASE'\n\n          }\n\n\n\n          data_merged_2<- data.frame(data_merged_2,Kinase = mykinvec)\n          data_merged_2\n\n        }\n\n\n      } else{\n\n        conc <- sigConc()\n        final.Names <- sigFinalNames()\n        pred.names <- sigPredNames()\n        colnames(data.merged[,1:input$chans]) <- final.Names\n        data_merged_positives<- data.merged\n        # na.omit(data.merged[data.merged[,1:input$chans] >= 1,])\n\n        data_merged_positives2<-( (1/data_merged_positives[,1:input$chans]))*100\n       if(input$incpd == TRUE){\n         Reps_FC<-data.frame(data_merged_positives2 ,\n                             Accession =  data_merged_positives$Accession,GeneID = data_merged_positives$GeneID,\n                             UniquePeps = data_merged_positives$UniquePeps, depletionConstant = data_merged_positives$Kd, MissingVal = data_merged_positives$MissingVal\n         )\n       }else{\n         Reps_FC<-data.frame(data_merged_positives2 ,\n                             Accession =  data_merged_positives$Accession,GeneID = data_merged_positives$GeneID,\n                             UniquePeps = data_merged_positives$UniquePeps, MissingVal = data_merged_positives$MissingVal\n         )\n       }\n\n        ryegrass.m1<- vector(mode = \"list\",length = nrow(Reps_FC))\n        pvals<-list()\n        stderr<-list()\n        model_pred<-list()\n        coeff_predicted<-list()\n        for(i in 1:nrow(Reps_FC)){\n          #print(i)\n\n          #nrow(full_df_2)\n          #maxIt and relTol to be user defined\n          ryegrass.m1[[i]]<-try(drm(as.numeric(Reps_FC[i,1:input$chans]) ~ as.numeric(conc),\n                                    na.action = na.omit,\n                                    control = drmc(constr = FALSE, errorm = FALSE, noMessage = TRUE, maxIt = 1000, relTol = 1e-06),\n                                    fct = LL.4(fixed=c(NA, NA, NA, NA), #see note @top this file\n                                               names = c(\"Slope\", \"Lower Limit\", \"Upper Limit\", \"RB50\"))),silent = T)\n\n        }\n\n        failed_sigm=0\n        for(i in 1:length(ryegrass.m1)){\n          #print(i)\n          #checking_val if FALSE  the model has failed to calculate the pval\n          checking_val<-try(is.numeric(coefficients(ryegrass.m1[[i]])[[\"Slope:(Intercept)\"]]),silent = T)\n\n          if(checking_val==\"TRUE\"){\n            #print(checking_val)\n            pvals[[i]]<-t(as.data.frame(summary(ryegrass.m1[[i]])$coefficients[13:16]))\n            colnames(pvals[[i]])<-c(\"SlopePval\", \"Lower_LimitPval\", \"Upper_LimitPval\", \"RB50Pval\")\n            coeff_predicted[[i]]<-t(data.frame(coefficients(ryegrass.m1[[i]])))\n            colnames(coeff_predicted[[i]])<-c(\"SlopeCoef\", \"Lower_LimitCoef\", \"Upper_LimitCoef\",\"RB50Coef\")\n            stderr[[i]]<-t(as.data.frame(summary(ryegrass.m1[[i]])$coefficients[5:8]))\n            colnames(stderr[[i]])<-c(\"SlopeErr\", \"Lower_LimitErr\", \"Upper_LimitErr\",\"RB50Err\")\n\n            model_pred[[i]]<-predict(ryegrass.m1[[i]])\n          }else{\n            failed_sigm=failed_sigm+1\n\n            fit <- lm(as.numeric(Reps_FC[i,1:input$chans]) ~ poly(log10(conc),2 ))\n            #extract the pval\n            pval<-as.numeric(summary(fit)$coefficients[,4] )\n            pvals[[i]]<- t(as.data.frame(c(pval,\"lm-fit:intercept.slope.quadratic\") ))\n            colnames(pvals[[i]])<-c(\"SlopePval\", \"Lower_LimitPval\", \"Upper_LimitPval\",\"RB50Pval\")\n            stderr[[i]]<- data.frame(NA,NA,NA,NA)\n            colnames(stderr[[i]])<-c(\"SlopeErr\", \"Lower_LimitErr\", \"Upper_LimitErr\",\"RB50Err\")\n            coeff_predicted[[i]]<-data.frame(NA,NA,NA,NA)\n            colnames(coeff_predicted[[i]])<-c(\"SlopeCoef\", \"Lower_LimitCoef\", \"Upper_LimitCoef\",\"RB50Coef\")\n            model_pred[[i]]<- as.numeric(fitted(fit))\n          } #just adding NAs for the times the model failed\n        }\n\n\n        modelsReps<-data.frame(\n          do.call(rbind.data.frame,lapply(model_pred,function(x) as.numeric(x))),\n          Reps_FC$GeneID,\n          do.call(rbind.data.frame,lapply(pvals,function(x) x) ),\n          do.call(rbind.data.frame,lapply(coeff_predicted,function(x) x)) ,\n          do.call(rbind.data.frame,lapply(stderr,function(x) x) )\n        )\n        colnames(modelsReps)<-c(pred.names,\"GeneID\",\n                                \"SlopePval\", \"Lower_LimitPval\",\"Upper_LimitPval\", \"RB50Pval\",\n                                \"SlopeCoef\", \"Lower_LimitCoef\",\"Upper_LimitCoef\", \"RB50Coef\",\n                                \"SlopeErr\", \"Lower_LimitErr\",\"Upper_LimitErr\", \"RB50Err\"\n        )\n        data_merged_2<-merge.data.frame(modelsReps,Reps_FC,by=\"GeneID\")\n\n          data_merged_2<-data.frame(data_merged_2,\"Top_minus_min\"=data_merged_2$predX1-data_merged_2[,paste(\"predX\",input$chans,sep = \"\")])\n\n\n        ## crapome integration\n\n\n        crap <- crapome()\n        #\n        tempcrap <- crap$Gene\n        tempcrap<- crap$percentagePresent[match(data_merged_2$GeneID,crap$Gene)]\n        data_merged_2 <- data.frame(data_merged_2, CRAPomePercent = tempcrap)\n\n        proteome<-as.vector(toupper(data_merged_2$GeneID))\n        mykinases <- intersect(proteome,kinome)\n\n        if(!is.null(input$venninp)){\n          myvenninp <- uploadVenn()\n          uploadsInt <- intersect(proteome,myvenninp)\n\n          myvenvec <- match(proteome, uploadsInt, nomatch = NA)\n\n          ## now combine with my kin vec\n\n          mykinvec <- match(proteome,mykinases, nomatch = NA)\n          mykinvec[!is.na(mykinvec) & !is.na(myvenvec)] <- 'KINASE + UPLOAD'\n          mykinvec[!is.na(mykinvec) & is.na(myvenvec)] <- 'KINASE'\n          mykinvec[is.na(mykinvec) & !is.na(myvenvec)] <- 'UPLOAD'\n          print(mykinvec)\n\n        } else {\n\n          mykinvec <- match(proteome,mykinases, nomatch = NA)\n          mykinvec[!is.na(mykinvec)]<- 'KINASE'\n\n        }\n\n\n        if(input$incpd == TRUE){\n\n          data_merged_2<- data.frame(data_merged_2, correctedRB50 = (data_merged_2$RB50Coef*data_merged_2$depletionConstant),Kinase = mykinvec)\n        }else{\n          data_merged_2<- data.frame(data_merged_2,Kinase = mykinvec)\n        }\n        data_merged_2\n\n      }\n\n    } else{\n      if(input$datype == \"intensity\"){\n        conc<- rep(0:(input$chans - 2), times = input$reps)\n\n      }else{\n\n        conc<- rep(0:(input$chans - 1), times = rReps())[channels()]\n\n      }\n\n      design<-model.matrix(~poly(conc,2))\n      colnames(design)<-c(\"Intercept\",\"Slope\",\"Quadratic\")\n\n      # reactive start\n\n      fit <- lmFit(data.merged[,1:length(conc)], method = \"ls\" , design = design )\n      fit <- eBayes(fit)\n\n      res <- topTable(fit, coef = \"Slope\", number = nrow(data.merged), adjust=\"BH\") #pval for the slope\n      res2 <- topTable(fit, coef = 1, number = nrow(data.merged), adjust=\"BH\")#pval for the intercept\n      res3 <- topTable(fit, coef = \"Quadratic\", number = nrow(data.merged), adjust=\"BH\") #pval for the quadratic term ()\n\n\n      #add the pvalues to the dataframe\n\n      tmp_1<- cbind(data.merged[rownames(res),],res)\n\n      tmp_2<- cbind(data.merged[rownames(res2),],res2)\n\n      tmp_3<- cbind(data.merged[rownames(res3),],res3)\n\n      ####\n\n\n\n      tobeselected <- merge.data.frame(tmp_1,tmp_2,by=\"Accession\")\n      tobeselected <- merge.data.frame(tobeselected,tmp_3,by=\"Accession\")\n      print(colnames(tobeselected))\n\n      selectnames <- c(paste0(colnames(data.merged)[1:length(conc)],\".x\"),\n                       \"logFC.x\", \"AveExpr.x\", \"P.Value\", \"adj.P.Val\", \"P.Value.x\",\n                       \"adj.P.Val.x\", \"P.Value.y\", \"adj.P.Val.y\",\"Accession\",\"GeneID.x\",\"UniquePeps\")\n\n\n      data.merged<- tobeselected[,match(selectnames, colnames(tobeselected))]\n      print(colnames(data.merged))\n      proteome<-as.vector(toupper(tobeselected$GeneID.x))\n      mykinases <- intersect(proteome,kinome)\n\n      if(!is.null(input$venninp)){\n        myvenninp <- uploadVenn()\n        uploadsInt <- intersect(proteome,myvenninp)\n\n        myvenvec <- match(proteome, uploadsInt, nomatch = NA)\n\n        ## now combine with my kin vec\n\n        mykinvec <- match(proteome,mykinases, nomatch = NA)\n        mykinvec[!is.na(mykinvec) & !is.na(myvenvec)] <- 'KINASE + UPLOAD'\n        mykinvec[!is.na(mykinvec) & is.na(myvenvec)] <- 'KINASE'\n        mykinvec[is.na(mykinvec) & !is.na(myvenvec)] <- 'UPLOAD'\n        print(mykinvec)\n\n      } else {\n\n        mykinvec <- match(proteome,mykinases, nomatch = NA)\n        mykinvec[!is.na(mykinvec)]<- 'KINASE'\n\n      }\n\n\n      crap <- crapome()\n      #\n      tempcrap <- crap$Gene\n      tempcrap<- crap$percentagePresent[match(toupper(data.merged$GeneID.x),crap$Gene)]\n      data.merged <- data.frame(data.merged, CRAPomePercent = tempcrap,Kinase = mykinvec)\n      print(colnames(data.merged))\n\n      nam <- finalNames()\n      if(input$datype == 'intensity'){\n        nam <- nam[-seq(1,input$reps*input$chans,by = input$chans)]\n      }\n      colnames(data.merged)[1:length(nam)] <- nam\n      # print(colnames(data.merged[match(c('P.Value', 'adj.P.Val', 'P.Value.x', 'adj.P.Val.x', 'P.Value.y', 'adj.P.Val.y'),colnames(data.merged))]))\n      # colnames(data.merged[,match(c('P.Value', 'adj.P.Val', 'P.Value.x', 'adj.P.Val.x', 'P.Value.y', 'adj.P.Val.y'),colnames(data.merged))]) <- c('P.Value_intercept', 'adj.P.Val_intercept', 'P.Value_slope', 'adj.P.Val_slope', 'P.Value_quadratic', 'adj.P.Val_quadratic')\n\n      # colnames(data.merged[match(c('P.Value', 'adj.P.Val', 'P.Value.x', 'adj.P.Val.x', 'P.Value.y', 'adj.P.Val.y'),colnames(data.merged))]) <- c('P.Value_intercept', 'adj.P.Val_intercept', 'P.Value_slope', 'adj.P.Val_slope', 'P.Value_quadratic', 'adj.P.Val_quadratic')\n      data.merged\n    }\n\n  })\n\n\n  rSu<- reactive({\n    if(input$reps == 1 ){\n\n\n      data.merged<- dataMerge()\n      data.merged\n\n    }else{\n      data.merged <- dataMerge2()\n      data.merged\n\n    }\n  })\n\n\n  ###################\n  ## output\n  ###################\n\n  output$venn <-  renderPlot({\n    req(data())\n    if(!is.null(input$venninp)){\n\n      upload <- uploadVenn()\n      upload<- as.vector(toupper(upload))\n      print(upload)\n      data.merged <- dataMerge()\n\n      proteome<-as.vector(toupper(data.merged$GeneID))\n      universe <- unique(c(kinome,proteome,upload))\n\n      count<- matrix(0, ncol = 3 , nrow = length(universe))\n      colnames(count) <- c(\"kinome\",'proteome','upload')\n\n      for(i in 1:length(universe)){\n        count[i,1]<- universe[i] %in% kinome\n        count[i,2]<- universe[i] %in% proteome\n        count[i,3]<- universe[i] %in% upload\n      }\n\n      vennDiagram(vennCounts(count), circle.col = c(\"blue\",\"red\",\"green\"), cex = 1,lwd = 2)\n\n\n    }else{\n\n      data.merged <- dataMerge()\n\n      proteome<-as.vector(toupper(data.merged$GeneID))\n      universe <- unique(c(kinome,proteome))\n      # Generate a matrix, with the sets in columns and possible letters on rows\n      Counts <- matrix(0, nrow=length(universe), ncol=2)\n      # Populate the said matrix\n      for (i in 1:length(universe)) {\n        Counts[i,1] <- universe[i] %in% kinome\n        Counts[i,2] <- universe[i] %in% proteome\n        #Counts[i,3] <- universe[i] %in% Metacore\n        #Counts[i,3] <- universe[i] %in% EXOCYTOSIS\n\n      }\n\n      colnames(Counts) <- c(\"Kinome\",\"Proteome\")\n      cols<-c(\"Red\", \"Blue\")\n\n      #### VENN\n\n      vennDiagram(vennCounts(Counts), circle.col=cols,\n                  cex=1, #title size\n                  lwd=2 #circle line size\n      )\n    }\n\n  })\n\n  output$bar<- renderPlot({\n    vec<- channels()\n    vec<- length(vec)\n    palette.bar <- rep(terrain.colors(input$reps),each = ifelse(input$datype != 'intensity',input$chans,input$chans - 1 ) )\n    data.merged<- dataMerge()\n    boxplot(data.merged[,1:vec], col=palette.bar,las=2, cex.axis=1, main=c(\"Box Plots\"),\n            ylab=c(\"Log2(ratios)\"))\n    legend(\"topright\",legend = paste(\"rep\",1:input$reps,sep = ' '), fill = terrain.colors(input$reps))\n\n  })\n\n\n  output$plot2<-renderPlot({\n\n    vec <- channels()\n    pal <- rainbow(length(vec))\n    leg.nam <- finalNames()\n    data.merged <- dataMerge()\n    missing_val <- 0\n\n    par(mfrow = c(1,2))\n    plot(x=rank(data.merged[,1]),y=data.merged[,1], cex.axis=1,\n         main=c(paste(\"N. of Missing val. \",missing_val ,\n                      \" \\n Change Distribution after LOESS\",sep=\"\")),\n         col=pal[1], ylab=c(\"Log2(ratios)\"), xlab = c(\"Proteins\"))\n    if(length(vec) > 1){\n      for(i in 2:length(vec)){\n        points(x=rank(data.merged[,i]),y=data.merged[,i], cex.axis=1, main=c(\"\"),col=pal[i])\n      }\n    }\n    legend(\"topleft\", legend = leg.nam, fill = pal)\n\n\n    plot(density(x=data.merged[,1]),col= pal[1], main=c(\" Density after LOESS\"), ylim = c(0,5 ),cex.axis = 1)\n    legend(\"topleft\", legend = leg.nam, fill = pal)\n\n    if(length(vec) > 1){\n      for(i in 2:length(vec)){\n        lines(density(x=data.merged[,i]), col=pal[i], main = c(\"\"))\n      }\n    }\n  })\n\n\n  output$plot3<- renderPlot({\n\n    vec <- channels()\n\n\n    data.merged<- dataMerge()\n    # print(colnames(data.merged))\n    meanSdPlot(as.matrix(data.merged[,1:length(vec)]))\n  })\n\n  output$plot4<- renderPlot({\n    if(input$modtyp == 'sigmoid'){\n      plot.new()\n      legend('topleft', c(\"Sigmoidal fit applied, no linear plots available\"),bty = 'n')\n    }else{\n\n\n    data.merged<- dataMerge2()\n    m0 <- ggplot(data.merged, aes(x=data.merged$P.Value))\n    m0<-m0 + geom_histogram(aes(fill = ..count..),binwidth = 0.01) +\n      scale_fill_gradient(\"Count\", low = \"green\", high = \"red\")+\n      xlab(\"P.val slope\")\n\n\n    m1 <- ggplot(data.merged, aes(x=data.merged$P.Value.x))\n    m1<- m1 + geom_histogram(aes(fill = ..count..),binwidth = 0.01) +\n      scale_fill_gradient(\"Count\", low = \"green\", high = \"red\")+\n      xlab(\"Pval intercept\")\n\n    m2 <- ggplot(data.merged, aes(x=data.merged$P.Value.y))\n    m2 <- m2 + geom_histogram(aes(fill = ..count..),binwidth = 0.01) +\n      scale_fill_gradient(\"Count\", low = \"green\", high = \"red\")+\n      xlab(\"Pval quadratic\")\n\n    grid.arrange(m0,m1,m2)\n    }\n  })\n\n  output$volcanoint<- renderPlot({\n\n    res<- dataMerge2()\n    # avgthr=0.2 #sign threshold for the averege fold change 0.3(log2)  is 1.3 FC\n\n    par(mar=c(5,5,5,10), xpd=TRUE)\n    # Make a basic volcano plot\n    with(res, plot(res$AveExpr.x, -log10(res$P.Value.x), pch=20, main=\"Volcano plot (Intercept pval )\",xlab=c(\"Log2_AvgFC\"),ylab=c(\"-Log10(Pval)\"), xlim=c(-abs(max(res$AveExpr.x)+1),abs(max(res$AveExpr.x)+1))))\n\n    # Add colored points: red if padj<0.05, orange of log2FC>1, green if both)\n    s=subset(res, P.Value.x<input$pvalsli )\n    with(s, points(s$AveExpr.x, -log10(s$P.Value.x), pch=20, col=\"red\"))\n\n    s=subset(res, abs(res$AveExpr.x)>input$avthrssli)\n    with(s, points(s$AveExpr.x, -log10(s$P.Value.x), pch=20, col=\"orange\"))\n\n    s=subset(res, P.Value.x<input$pvalsli & abs(res$AveExpr.x)>input$avthrssli)\n    with(s, points(s$AveExpr.x, -log10(s$P.Value.x), pch=20, col=\"green\"))\n\n    # Label points with the textxy function from the calibrate plot\n    s=subset(res, P.Value.x<input$pvalsli & abs(res$AveExpr.x)>input$avthrssli)\n    with(s, textxy( s$AveExpr.x, -log10(s$P.Value.x),  labs=s$GeneID.x, cex=1)\n    )\n    legend(\"bottomleft\", title=\"Legend\",cex = 0.8,\n           c(\"Not significant\",\n             paste(\"P.Value\",input$pvalsli, sep = \" \"), #red\n             paste(\"AvgFC >\", input$avthrssli, sep=\"\"), #orange,\n             paste(\"P.Value\", input$pvalsli,\"& AvgFC >\", input$avthrssli, sep=\"\") #green\n           ),\n           col=c(\"black\",\"red\",\"orange\",\"green\"),\n           horiz=F, pch=c(19))\n\n\n\n  })\n\n  output$volcanoquad<- renderPlot({\n\n    res<- dataMerge2()\n    # avgthr=0.2 #sign threshold for the averege fold change 0.3(log2)  is 1.3 FC\n\n    par(mar=c(5,5,5,10), xpd=TRUE)\n    # Make a basic volcano plot\n    with(res, plot(res$AveExpr.x, -log10(res$P.Value.y), pch=20, main=\"Volcano plot (Quadratic pval )\",xlab=c(\"Log2_AvgFC\"),ylab=c(\"-Log10(Pval)\"), xlim=c(-abs(max(res$AveExpr.x)+1),abs(max(res$AveExpr.x)+1))))\n\n    # Add colored points: red if padj<0.05, orange of log2FC>1, green if both)\n    s=subset(res, P.Value.y<input$pvalsli )\n    with(s, points(s$AveExpr.x, -log10(s$P.Value.y), pch=20, col=\"red\"))\n\n    s=subset(res, abs(res$AveExpr.x)>input$avthrssli)\n    with(s, points(s$AveExpr.x, -log10(s$P.Value.y), pch=20, col=\"orange\"))\n\n    s=subset(res, P.Value.y<input$pvalsli & abs(res$AveExpr.x)>input$avthrssli)\n    with(s, points(s$AveExpr.x, -log10(s$P.Value.y), pch=20, col=\"green\"))\n\n    # Label points with the textxy function from the calibrate plot\n    s=subset(res, P.Value.y<input$pvalsli & abs(res$AveExpr.x)>input$avthrssli)\n    with(s, textxy( s$AveExpr.x, -log10(s$P.Value.y),  labs=s$GeneID.x, cex=.9)\n    )\n    legend(\"bottomleft\", title=\"Legend\",cex = 0.7,\n           c(\"Not significant\",\n             paste(\"P.Value\",input$pvalsli, sep = \" \"), #red\n             paste(\"AvgFC >\", input$avthrssli, sep=\"\"), #orange,\n             paste(\"P.Value\", input$pvalsli,\"& AvgFC >\", input$avthrssli, sep=\"\") #green\n           ),\n           col=c(\"black\",\"red\",\"orange\",\"green\"),\n           horiz=F, pch=c(19))\n\n\n\n  })\n\n\n  output$repvsrep1 <- renderUI({\n    # a <- finalNames()\n    # a <- paste0(a,\".x\")\n    # b <- channels()\n    a<- indexmatrix()\n    selectizeInput(inputId = \"repvsrep1\",label = \"Select Condition\", choices = as.character(a$names), multiple = FALSE)\n  })\n\n  output$repvsrep2 <- renderUI({\n    a <- finalNames()\n    a <- paste0(a,\".x\")\n\n    b <- channels()\n    c <- a[b]\n    if(is.null(input$repvsrep1)){\n      e <- c\n    } else {\n      d <- match(input$repvsrep1,c)\n      e <- c[-d]\n    }\n\n    selectInput(inputId = \"repvsrep2\",label = \"Select Condition\", choices = e, multiple = FALSE)\n  })\n\n  output$repvsrep <- renderPlot({\n    if(input$reps > 1){\n\n      data.merged <- dataMerge2()\n      index <- indexmatrix()\n      val = max(c(max(data.merged[,index[index[,1] == input$repvsrep1,5]],na.rm = TRUE),max(data.merged[,index[index[,1] == input$repvsrep1,6]],na.rm = TRUE)))\n\n\n      plot(x=data.merged[,index[index[,1] == input$repvsrep1,5]],y=data.merged[,index[index[,1] == input$repvsrep1,6]], xlim=c(0,val +0.2), col=\"green\" , ylim=c(0,val+0.2),\n           cex.axis=1.2, main=c(\"LogFC-LogFC Plots\"),\n           xlab=paste(\"rep\",index[index[,1] == input$repvsrep1,3]),  ylab=paste(\"rep\",index[index[,1] == input$repvsrep1,4]))\n      text(data.merged[,index[index[,1] == input$repvsrep1,5]], data.merged[,index[index[,1] == input$repvsrep1,6]], labels=data.merged$GeneID, cex= 1,pos=4)\n      lines(x = c(0,val), y = c(0,val),col=\"red\")\n    } else {\n      plot.new()\n      title(main = 'Plot not available: only 1 replicate')\n\n    }\n\n  })\n\n  output$plot5<- renderPlot({\n    req(data())\n    if(input$modtyp == 'sigmoid'){\n      su <- dataMerge()\n    }else{\n\n      su<-  rSu()\n    }\n\n    index<- channels()\n    index<- length(index)\n    cmat <-cor(su[,1:index],use=\"pairwise\", method = \"pearson\")\n    corrgram(cmat, order=TRUE, lower.panel=panel.shadeNtext,\n             upper.panel=panel.pie, text.panel=panel.txt,\n             main=\"Corrgram Plots\" )\n\n\n  })\n\n\n  ### MeanDiff\n\n  output$meandiff1 <- renderUI({\n\n    a <- indexmatrix()\n\n    selectizeInput(inputId = \"meandiff1\",label = \"Select Condition\", choices = as.character(a$names), multiple = FALSE)\n  })\n\n  output$meandiff2 <- renderUI({\n    a <- finalNames()\n    a <- paste0(a,\".x\")\n\n    b <- channels()\n    c <- a[b]\n    if(is.null(input$meandiff1)){\n      e <- c\n    } else {\n      d <- match(input$meandiff1,c)\n      e <- c[-d]\n    }\n\n    selectInput(inputId = \"meandiff2\",label = \"Select Condition\", choices = e, multiple = FALSE)\n  })\n\n  output$plot6<- renderPlot({\n\n    req(data())\n    if(input$modtyp == 'sigmoid'){\n      plot.new()\n      title(main = 'Plot not available: only 1 replicate')\n    }else{\n      # data.merged <- dataMerge()\n      su <- rSu()\n      index <- indexmatrix()\n      minxy <- min(c(min(su[,index[index[,1] == input$meandiff1,5]]),min(su[,index[index[,1] == input$meandiff1,6]])))\n      maxxy <- max(c(max(su[,index[index[,1] == input$meandiff1,5]]),max(su[,index[index[,1] == input$meandiff1,6]])))\n\n      tmd(\n        xyplot(su[,index[index[,1] == input$meandiff1,5]] ~ su[,index[index[,1] == input$meandiff1,6]]), main=input$meandiff1,xlim = c(minxy,maxxy),\n        ylim = c(minxy,maxxy),\n        panel=function(x, y, ...) {\n          panel.xyplot(x, y, ...);\n          ltext(x=x, y=y, labels=su$GeneID, pch=c(13,3,16), cex=0.5, lwd=2, pos=1, offset=1, pch = 19)\n        }\n      )\n    }\n\n\n  })\n\n\n  output$plot7<- renderPlot({\n    req(data())\n    if( input$datype == 'intensity'){\n\n      nchan<- input$chans - 1\n\n    }else{\n\n      nchan<- input$chans\n    }\n\n    su <- rSu()\n    reps <- input$reps\n    index <- channels()\n    print(.libPaths())\n    print(all.equal(1:nchan,index))\n    print(input$reps)\n    pca <- prcomp(su[,1:length(index)], scale=F)\n\n    DTA<-data.frame( as.numeric(t(su[,1:length(index)])%*%pca$x[,1]),\n                     as.numeric(t(su[,1:length(index)])%*%pca$x[,2]))\n\n    print(DTA)\n\n    p<-ggplot(DTA, aes(x=DTA$as.numeric.t.su...1.length.index........pca.x...1..,\n                       y=DTA$as.numeric.t.su...1.length.index........pca.x...2..))\n\n    paste0(\"PC1\", \" (\", round(pca$sdev[1]/sum(pca$sdev)*100,0), \"%)\")\n\n    shapeval <- c(15:18,7:12)\n    p <- p + geom_point(aes(colour = factor(rep(1:print(input$reps),each = (nchan)),labels = paste(\"Rep\",1:print(input$reps)))[index],\n                            shape = factor(rep(1:nchan,print(input$reps)),labels = c(paste(\"C\",0:(nchan-1),sep = \"\")))[index] ), size = 5 ) +\n      scale_shape_manual(values=shapeval[1:nchan]) + labs(x = paste0(\"PC1\", \" (\", round(pca$sdev[1]/sum(pca$sdev)*100,0), \"%)\"),\n                                                          y = paste0(\"PC2\", \" (\", round(pca$sdev[2]/sum(pca$sdev)*100,0), \"%)\"), title=\"PCA\") + labs(color = \"Replicates\", shape=\"Concentration\")\n\n    print(p)\n\n  })\n\n\n\n\n  output$plot8<- renderPlot({\n    if( input$modtyp == 'sigmoid'){\n      plot.new()\n      title(main = 'Plot not available: Sigmoidal fit applied')\n\n    }else{\n\n      res<- dataMerge2()\n      # avgthr=0.2 #sign threshold for the averege fold change 0.3(log2)  is 1.3 FC\n\n      par(mar=c(5,5,5,10), xpd=TRUE)\n      # Make a basic volcano plot\n      with(res, plot(res$AveExpr.x, -log10(res$P.Value), pch=20, main=\"Volcano plot (slope pval )\",\n                     xlab=c(\"Log2_AvgFC\"),ylab=c(\"-Log10(Pval)\"),\n                     xlim=c(-abs(max(res$AveExpr.x)+1),abs(max(res$AveExpr.x)+1))))\n\n      # Add colored points: red if padj<0.05, orange of log2FC>1, green if both)\n      s=subset(res, P.Value< input$pvalsli )\n      with(s, points(s$AveExpr.x, -log10(s$P.Value), pch=20, col=\"red\"))\n\n      s=subset(res, abs(res$AveExpr.x)>input$avthrssli)\n      with(s, points(s$AveExpr.x, -log10(s$P.Value), pch=20, col=\"orange\"))\n\n      s=subset(res, P.Value< input$pvalsli & abs(res$AveExpr.x)>input$avthrssli)\n      with(s, points(s$AveExpr.x, -log10(s$P.Value), pch=20, col=\"green\"))\n\n      # Label points with the textxy function from the calibrate plot\n      s=subset(res, P.Value< input$pvalsli & abs(res$AveExpr.x)>input$avthrssli)\n      with(s, textxy( s$AveExpr.x, -log10(s$P.Value),  labs=s$GeneID, cex=1)\n      )\n      legend(\"bottomleft\", title=\"Legend\",cex = 0.7,\n             c(\"Not significant\",\n               paste(\"P.Value\",input$pvalsli, sep = \" \"), #red\n               paste(\"AvgFC >\", input$avthrssli, sep=\"\"), #orange,\n               paste(\"P.Value\", input$pvalsli,\"& AvgFC >\", input$avthrssli, sep=\"\") #green\n             ),\n             col=c(\"black\",\"red\",\"orange\",\"green\"),\n             horiz=F, pch=c(19))\n    }\n  })\n\n  output$plot9<- renderD3heatmap({\n    req(data())\n    if(input$modtyp == 'sigmoid'){\n      su <- dataMerge()\n      print(head(su))\n      if(input$datype =='intensity'){\n\n        su1 <- su[,1:(input$chans - 1 )]\n      }else{\n        su1 <- su[,1:(input$chans )]\n      }\n    } else {\n\n      su <- rSu()\n      vec <- channels()\n      vec <- length(vec)\n\n      su1 <- su[,1:(vec)]\n      vec.nam <- finalNames()\n      vec.nam <- vec.nam[channels()]\n      colnames(su)[match('GeneID.x',colnames(su))] <- 'GeneID'\n    }\n\n\n\n    d3heatmap(su1, Colv = FALSE,labRow = as.character(make.names(su$GeneID,unique = TRUE)), dendrogram = 'row' )\n\n\n  })\n\n  output$test<- DT::renderDataTable({\n\n    fin<- standardNames()\n\n    if(length(input$view_vars) == length(fin)){\n\n      DT::datatable(data.frame(Original = input$view_vars,Standard = standardNames(), Final = finalNames()))\n    }else{\n      DT::datatable(data.frame(Error = \"Incorrect dimensions\", Comments=  \"ensure the nunmber of names selected is the same as the number of channels and repeats inputted\"))\n    }\n\n\n  })\n\n  ############## Info Boxes\n\n  ### P value\n  pvalQc <- reactive({\n\n    data.merged <- dataMerge2()\n    PVal <-  c(sum(data.merged$P.Value <= 0.05),sum(data.merged$P.Value.x <= 0.05),\n               sum(data.merged$P.Value.y <= 0.05))\n\n    Names = c(\"Slope\", \"Intercept\", \"Quadratic\")\n\n\n\n    data.frame(Names = Names, PVal = PVal)\n\n  })\n\n  output$infopvalslo <- renderInfoBox({\n    temp <- pvalQc()\n    infoBox(\n      title = \"Slope\",paste0(temp[1,2], \" p values < 0.05\"),color = ifelse(temp[1,2] > 0, \"green\",\"orange\" ), icon = icon(ifelse(temp[1,2] > 0, \"check\",\"warning\" ))\n    )\n  })\n\n  output$infopvalint <- renderInfoBox({\n    temp <- pvalQc()\n    infoBox(\n      title = \"Intercept\",paste0(temp[2,2], \" p values < 0.05\"),color = ifelse(temp[2,2] > 0, \"green\",\"orange\" ), icon = icon(ifelse(temp[2,2] > 0, \"check\",\"warning\" ))\n    )\n  })\n\n  output$infopvalquad <- renderInfoBox({\n    temp <- pvalQc()\n    infoBox(\n      title = \"Quadratic\",paste0(temp[3,2], \" p values < 0.05\"),color = ifelse(temp[3,2] > 0, \"green\",\"orange\" ), icon = icon(ifelse(temp[2,2] > 0, \"check\",\"warning\" ))\n    )\n  })\n\n  output$corrinfo <- renderInfoBox({\n    req(data())\n    if(input$modtyp == 'sigmoid'){\n      su <- dataMerge()\n    }else{\n      su <- rSu()\n\n    }\n    cmat <-cor(su[,channels()],use=\"pairwise\", method = \"pearson\")\n    cmat[upper.tri(cmat)]<- 0\n    cmat<- melt(cmat)\n\n\n    infoBox(\n      title = NULL,value = ifelse(nrow(cmat[cmat$value < 0, ]) == 0, \"No Anti-Correlation between Channels\",\"Anti Correlation between some Channels\" ),\n      color = ifelse(nrow(cmat[cmat$value < 0, ]) == 0, \"green\",\"orange\" ),\n      icon = icon(ifelse(nrow(cmat[cmat$value < 0, ]) == 0, \"check\",\"warning\" ))\n    )\n\n  })\n\n  output$siginfodt <- renderInfoBox({\n\n    if(input$modtyp == 'lin'){\n      return(NULL)\n    } else {\n\n      conc<- sigConc()\n      if(input$datype == 'intensity'){\n\n\n        top<-15 #max prot to plot\n\n        data_merged_2 <- dataMerge2()\n\n        # RB50<-na.omit(data_merged_2[data_merged_2$RB50Err < as.numeric(summary(data_merged_2$RB50Err)[5]) & data_merged_2$RB50Pval<0.05 & data_merged_2$predX1-data_merged_2$predX9 >0 & data_merged_2$predX1 <= 100,])\n        RB50 <- data.frame(na.omit(data_merged_2[data_merged_2$RB50Err < as.numeric(summary(data_merged_2$RB50Err)[5]) & data_merged_2$RB50Pval < 0.05\n                                                 & data_merged_2$predX1-data_merged_2[,paste(\"predX\",(input$chans - 1),sep = \"\")] >0 & data_merged_2$predX1 <= 100,]))\n\n\n        RB50_ordered<- na.omit(RB50[order(RB50$RB50Pval, decreasing = F),][1:top,])\n\n\n      } else{\n        pred.names <- sigPredNames()\n        final.Names <- finalNames()\n        top<-15 #max prot to plot\n\n        data_merged_2 <- dataMerge2()\n\n        # RB50<-na.omit(data_merged_2[data_merged_2$RB50Err < as.numeric(summary(data_merged_2$RB50Err)[5]) & data_merged_2$RB50Pval<0.05 & data_merged_2$predX1-data_merged_2$predX9 >0 & data_merged_2$predX1 <= 100,])\n        RB50 <- data.frame(na.omit(data_merged_2[data_merged_2$RB50Err < as.numeric(summary(data_merged_2$RB50Err)[5]) & data_merged_2$RB50Pval < 0.05\n                                                 & data_merged_2$predX1-data_merged_2[,paste(\"predX\",input$chans,sep = \"\")] >0 & data_merged_2$predX1 <= 100,]))\n\n\n        RB50_ordered<- na.omit(RB50[order(RB50$RB50Pval, decreasing = F),][1:top,])\n\n      }\n\n      infoBox(\n        title = \"RB50\",paste0(nrow(RB50_ordered), \" Significant RB50\"),color = ifelse(nrow(RB50_ordered) > 0, \"green\",\"orange\" ), icon = icon(ifelse(nrow(RB50_ordered) > 0, \"check\",\"warning\" ))\n      )\n\n\n    }\n\n  })\n\n  output$siginfoslop <- renderInfoBox({\n\n    if(input$modtyp == 'lin'){\n      return(NULL)\n    } else {\n\n      conc<- sigConc()\n      if(input$datype == 'intensity'){\n\n        top<-15 #max prot to plot\n\n        conc<- sigConc()\n        pred.names <- paste0('predX',1:(input$chans -1))\n        final.Names <- paste0('rep1_C',0:(input$chans - 2))\n\n        data_merged_2 <- dataMerge2()\n\n        #Here make the subselections for using the ggplot functions SLOPE\n        slope<-na.omit(data_merged_2[data_merged_2$SlopePval<0.05 ,])\n        slope_ordered<-na.omit(slope[order(slope$SlopePval, decreasing = F),][1:top,])\n\n\n      } else{\n\n        top<-15 #max prot to plot\n\n        conc<- sigConc()\n        pred.names <- sigPredNames()\n        final.Names <- finalNames()\n\n        data_merged_2 <- dataMerge2()\n\n        #Here make the subselections for using the ggplot functions SLOPE\n        slope<-na.omit(data_merged_2[data_merged_2$SlopePval<0.05 ,])\n        slope_ordered<-na.omit(slope[order(slope$SlopePval, decreasing = F),][1:top,])\n\n      }\n\n      infoBox(\n        title = \"Slope Coefficient\",paste0(nrow(slope_ordered), \" Significant Slope\"),color = ifelse(nrow(slope_ordered) > 0, \"green\",\"orange\" ), icon = icon(ifelse(nrow(slope_ordered) > 0, \"check\",\"warning\" ))\n      )\n\n\n    }\n\n  })\n\n  output$siginfodiff <- renderInfoBox({\n\n    if(input$modtyp == 'lin'){\n      return(NULL)\n    } else {\n\n      conc<- sigConc()\n      if(input$datype == 'intensity'){\n\n\n        data_merged_2 <- dataMerge2()\n        pred.names <- paste0('predX',1:(input$chans -1))\n        final.Names <- paste0('rep1_C',0:(input$chans - 2))\n\n        topperc<-30 #difference in % between top and bottom\n        # data_merged_2 <- dataMerge2()\n        diffinter<- data_merged_2[(data_merged_2$predX1 -data_merged_2[,paste(\"predX\",(input$chans-1),sep = \"\")]) > topperc & data_merged_2$predX1 <= 100, ]\n\n\n\n      } else{\n        conc<- sigConc()\n\n        pred.names <- sigPredNames()\n        final.Names <- finalNames()\n\n        topperc<-30 #difference in % between top and bottom\n        data_merged_2 <- dataMerge2()\n        diffinter<- data_merged_2[(data_merged_2$predX1 -data_merged_2[,paste(\"predX\",input$chans,sep = \"\")]) > topperc & data_merged_2$predX1 <= 100, ]\n\n\n      }\n\n      infoBox(\n        title = \"Top - Bottom Difference\",paste0(nrow(diffinter), \" Significant Difference\"),color = ifelse(nrow(diffinter) > 0, \"green\",\"orange\" ), icon = icon(ifelse(nrow(diffinter) > 0, \"check\",\"warning\" ))\n      )\n\n\n    }\n\n  })\n  ############################\n  # SIGMOIDAL PLOTS\n  ############################\n\n\n  output$DiffTopBottom <- renderPlot({\n\n    if(input$modtyp != 'sigmoid'){\n      plot.new()\n      legend('topleft', c(\"Linear fit applied, no sigmoidal plots available\"),bty = 'n')\n    }else{\n      if(input$datype == 'intensity'){\n        data_merged_2 <- dataMerge2()\n        conc<- sigConc()\n        pred.names <- paste0('predX',1:(input$chans -1))\n        final.Names <- paste0('rep1_C',0:(input$chans - 2))\n\n        topperc<-30 #difference in % between top and bottom\n        # data_merged_2 <- dataMerge2()\n        diffinter<- data_merged_2[(data_merged_2$predX1 -data_merged_2[,paste(\"predX\",(input$chans-1),sep = \"\")]) > topperc & data_merged_2$predX1 <= 100, ]\n\n\n        if(nrow(diffinter)>0){\n          Diff_Top_bottom_pred<-shape_for_ggplot_pred(diffinter,log2(conc),pred.names)\n          Diff_Top_bottom_perc<-shape_for_ggplot_perc(diffinter,log2(conc),final.Names)\n          what<-c(\"(Top - Bottom) >\")\n\n          Diff_Top_bottom<-ggplot()+\n            geom_line(data = Diff_Top_bottom_pred, aes(x=x,y=value, colour=factor(Diff_Top_bottom_pred$GeneID)), size = 1) +\n            geom_point(data = Diff_Top_bottom_perc, aes(x=x,y=value, colour=Diff_Top_bottom_perc$GeneID)) +\n            labs(title=paste(what,topperc,sep=\"\"))\n\n\n        }else{\n          Diff_Top_bottom<-ggplot()+\n            labs(title=paste(\"No significant Top-Bottom >\" ,topperc,\"%\",\"\\n\",\"has been found\", sep=\"\"))\n        }\n\n        print(Diff_Top_bottom)\n      }\n\n      else{\n        conc<- sigConc()\n\n        pred.names <- sigPredNames()\n        final.Names <- finalNames()\n\n        topperc<-30 #difference in % between top and bottom\n        data_merged_2 <- dataMerge2()\n        diffinter<- data_merged_2[(data_merged_2$predX1 -data_merged_2[,paste(\"predX\",input$chans,sep = \"\")]) > topperc & data_merged_2$predX1 <= 100, ]\n\n\n\n\n        if(nrow(diffinter)>0){\n          Diff_Top_bottom_pred<-shape_for_ggplot_pred(diffinter,log2(conc),pred.names)\n          Diff_Top_bottom_perc<-shape_for_ggplot_perc(diffinter,log2(conc),final.Names)\n          what<-c(\"(Top - Bottom) >\")\n\n          Diff_Top_bottom<-ggplot()+\n            geom_line(data = Diff_Top_bottom_pred, aes(x=x,y=value, colour=factor(Diff_Top_bottom_pred$GeneID)), size = 1) +\n            geom_point(data = Diff_Top_bottom_perc, aes(x=x,y=value, colour=Diff_Top_bottom_perc$GeneID)) +\n            labs(title=paste(what,topperc,sep=\"\"))\n\n\n        }else{\n          Diff_Top_bottom<-ggplot()+\n            labs(title=paste(\"No significant Top-Bottom >\" ,topperc,\"%\",\"\\n\",\"has been found\", sep=\"\"))\n        }\n\n        print(Diff_Top_bottom)\n      }\n    }\n\n\n  })\n\n  output$Slope_pl <- renderPlot({\n\n    if(input$modtyp != 'sigmoid'){\n      plot.new()\n      legend('topleft', c(\"Linear fit applied, no sigmoidal plots available\"),bty = 'n')\n    }else{\n\n      if(input$datype == 'intensity'){\n        top<-15 #max prot to plot\n\n        conc<- sigConc()\n        pred.names <- paste0('predX',1:(input$chans -1))\n        final.Names <- paste0('rep1_C',0:(input$chans - 2))\n\n        data_merged_2 <- dataMerge2()\n\n        #Here make the subselections for using the ggplot functions SLOPE\n        slope<-na.omit(data_merged_2[data_merged_2$SlopePval<0.05 ,])\n        slope_ordered<-na.omit(slope[order(slope$SlopePval, decreasing = F),][1:top,])\n        if(nrow(slope_ordered)>0){\n          slope_pred<-shape_for_ggplot_pred(slope_ordered,log10(conc),pred.names)\n          slope_perc<- shape_for_ggplot_perc(slope_ordered,log10(conc),final.Names)\n          what<-c(\"Slope (p.val) \")\n          Slope_pl<-ggplot()+\n            geom_line(data = slope_pred, aes(x=x,y=value, colour=factor(slope_pred$GeneID)), size = 1) +\n            geom_point(data = slope_perc, aes(x=x,y=value,colour=slope_perc$GeneID))+\n            labs(title=paste(what,\"Top\",top,sep=\"\"))\n\n        }else{Slope_pl<-ggplot()+\n          labs(title=\"No significant Sigmoidal Slope has been found\")\n        }\n        print(Slope_pl)\n      } else{\n        top<-15 #max prot to plot\n\n        conc<- sigConc()\n        pred.names <- sigPredNames()\n        final.Names <- finalNames()\n\n        data_merged_2 <- dataMerge2()\n\n        #Here make the subselections for using the ggplot functions SLOPE\n        slope<-na.omit(data_merged_2[data_merged_2$SlopePval<0.05 ,])\n        slope_ordered<-na.omit(slope[order(slope$SlopePval, decreasing = F),][1:top,])\n        if(nrow(slope_ordered)>0){\n          slope_pred<-shape_for_ggplot_pred(slope_ordered,log10(conc),pred.names)\n          slope_perc<- shape_for_ggplot_perc(slope_ordered,log10(conc),final.Names)\n          what<-c(\"Slope (p.val) \")\n          Slope_pl<-ggplot()+\n            geom_line(data = slope_pred, aes(x=x,y=value, colour=factor(slope_pred$GeneID)), size = 1) +\n            geom_point(data = slope_perc, aes(x=x,y=value,colour=slope_perc$GeneID))+\n            labs(title=paste(what,\"Top\",top,sep=\"\"))\n\n        }else{Slope_pl<-ggplot()+\n          labs(title=\"No significant Sigmoidal Slope has been found\")\n        }\n        print(Slope_pl)\n      }\n    }\n\n\n  })\n\n  output$RB50 <- renderPlot({\n\n    if(input$modtyp != 'sigmoid'){\n      plot.new()\n      legend('topleft', c(\"Linear fit applied, no sigmoidal plots available\"),bty = 'n')\n    }else{\n      if(input$datype =='intensity'){\n        conc<- sigConc()\n\n        pred.names <- paste0('predX',1:(input$chans -1))\n        final.Names <- paste0('rep1_C',0:(input$chans - 2))\n\n        top<-15 #max prot to plot\n\n        data_merged_2 <- dataMerge2()\n\n        # RB50<-na.omit(data_merged_2[data_merged_2$RB50Err < as.numeric(summary(data_merged_2$RB50Err)[5]) & data_merged_2$RB50Pval<0.05 & data_merged_2$predX1-data_merged_2$predX9 >0 & data_merged_2$predX1 <= 100,])\n        RB50 <- data.frame(na.omit(data_merged_2[data_merged_2$RB50Err < as.numeric(summary(data_merged_2$RB50Err)[5]) & data_merged_2$RB50Pval < 0.05\n                                                 & data_merged_2$predX1-data_merged_2[,paste0('predX',(input$chans - 1))] >0 & data_merged_2$predX1 <= 100,]))\n\n\n        RB50_ordered<- na.omit(RB50[order(RB50$RB50Pval, decreasing = F),][1:top,])\n\n        if(nrow(RB50_ordered)>0){\n          RB50_pred<-shape_for_ggplot_pred(RB50_ordered,log10(conc),pred.names)\n          RB50_perc<-shape_for_ggplot_perc(RB50_ordered,log10(conc),final.Names)\n          what<-c(\"RB50 (p.val) \")\n          RB50_pl<-ggplot()+\n            geom_line(data = RB50_pred, aes(x=x,y=value, colour=factor(RB50_pred$GeneID)), size = 1) +\n            geom_point(data = RB50_perc, aes(x=x,y=value,colour=RB50_perc$GeneID))+\n            labs(title=paste(what,\"Top\",top,sep=\"\"))\n          print(RB50_pl)\n        }else{\n          RB50_pl<-ggplot()+\n            labs(title=\"No significant RB50 has been found\")\n        print(RB50_pl)\n        }\n\n      }else {\n        conc<- sigConc()\n        pred.names <- sigPredNames()\n        final.Names <- finalNames()\n        top<-15 #max prot to plot\n\n        data_merged_2 <- dataMerge2()\n\n        # RB50<-na.omit(data_merged_2[data_merged_2$RB50Err < as.numeric(summary(data_merged_2$RB50Err)[5]) & data_merged_2$RB50Pval<0.05 & data_merged_2$predX1-data_merged_2$predX9 >0 & data_merged_2$predX1 <= 100,])\n        RB50 <- data.frame(na.omit(data_merged_2[data_merged_2$RB50Err < as.numeric(summary(data_merged_2$RB50Err)[5]) & data_merged_2$RB50Pval < 0.05\n                                                 & data_merged_2$predX1-data_merged_2$predX9 >0 & data_merged_2$predX1 <= 100,]))\n\n\n        RB50_ordered<- na.omit(RB50[order(RB50$RB50Pval, decreasing = F),][1:top,])\n\n        if(nrow(RB50_ordered)>0){\n          RB50_pred<-shape_for_ggplot_pred(RB50_ordered,log10(conc),pred.names)\n          RB50_perc<-shape_for_ggplot_perc(RB50_ordered,log10(conc),final.Names)\n          what<-c(\"RB50 (p.val) \")\n          RB50_pl<-ggplot()+\n            geom_line(data = RB50_pred, aes(x=x,y=value, colour=factor(RB50_pred$GeneID)), size = 1) +\n            geom_point(data = RB50_perc, aes(x=x,y=value,colour=RB50_perc$GeneID))+\n            labs(title=paste(what,\"Top\",top,sep=\"\"))\n        }else{\n          RB50_pl<-ggplot()+\n            labs(title=\"No significant RB50 has been found\")\n        }\n        print(RB50_pl)\n      }\n    }\n\n  })\n\n\n\n  # Linear elements of sigmoidal obselete\n\n  # output$Linear_pl1 <- renderPlot({\n  #\n  #   if(input$modtyp != 'sigmoid'){\n  #     plot.new()\n  #     legend('topleft', c(\"Linear fit applied, no sigmoidal plots available\"),bty = 'n')\n  #   }else{\n  #     conc<- sigConc()\n  #\n  #     pred.names <- sigPredNames()\n  #     final.Names <- finalNames()\n  #     top<-15 #max prot to plot\n  #\n  #     data_merged_2 <- dataMerge2()\n  #\n  #\n  #     linere<-data_merged_2[data_merged_2$RB50Pval==\"lm-fit:intercept.slope.quadratic\" & data_merged_2$predX1 > data_merged_2[,paste(\"predX\",input$chans,sep = \"\")] & data_merged_2$predX1 <= 100 & data_merged_2$Lower_LimitPval < 0.05,]\n  #\n  #     if(nrow(linere)>0){\n  #       lin_pred<-shape_for_ggplot_pred(linere,log10(conc),pred.names)\n  #       lin_perc<-shape_for_ggplot_perc(linere,log10(conc),final.Names)\n  #       what<-c(\"Lm model Slope Pval< 0.05 \\n (failed dose-resp.) \")\n  #\n  #       Linear_pl1<-ggplot()+\n  #         geom_line(data = lin_pred, aes(x=x,y=value, colour=factor(lin_pred$GeneID)), size = 1) +\n  #         geom_point(data = lin_perc, aes(x=x,y=value,colour=lin_perc$GeneID))+\n  #         labs(title=paste(what,top,sep=\"\"))\n  #\n  #\n  #     }else{\n  #       Linear_pl1<-ggplot()+\n  #         labs(title=\"No significant Lm slope has been found\")\n  #     }\n  #\n  #     print(Linear_pl1)\n  #   }\n  # })\n  #\n  # output$Linear_pl2 <- renderPlot({\n  #\n  #   if(input$modtyp != 'sigmoid'){\n  #     plot.new()\n  #     legend('topleft', c(\"Linear fit applied, no sigmoidal plots available\"),bty = 'n')\n  #   }else{\n  #     conc<- sigConc()\n  #     pred.names <- sigPredNames()\n  #     final.Names <- finalNames()\n  #     top<-15 #max prot to plot\n  #\n  #     data_merged_2 <- dataMerge2()\n  #\n  #\n  #     linere<-data_merged_2[data_merged_2$RB50Pval==\"lm-fit:intercept.slope.quadratic\" & data_merged_2$predX1 > data_merged_2[,paste(\"predX\",input$chans,sep = \"\")] & data_merged_2$predX1 <= 100 & data_merged_2$Upper_LimitPval < 0.05,]\n  #\n  #     if(nrow(linere)>0){\n  #       lin_pred<-shape_for_ggplot_pred(linere,log10(conc),pred.names)\n  #       lin_perc<-shape_for_ggplot_perc(linere,log10(conc),final.Names)\n  #       what<-c(\"Lm model Quadratic Pval< 0.05 \\n (failed dose-resp.) \")\n  #\n  #       Linear_pl2<-ggplot()+\n  #         geom_line(data = lin_pred, aes(x=x,y=value, colour=factor(lin_pred$GeneID)), size = 1) +\n  #         geom_point(data = lin_perc, aes(x=x,y=value,colour=lin_perc$GeneID))+\n  #         labs(title=paste(what,top,sep=\"\"))\n  #\n  #\n  #     }else{\n  #       Linear_pl2<-ggplot()+\n  #         labs(title=\"No significant Lm Quadratic has been found\")\n  #     }\n  #\n  #\n  #     print(Linear_pl2)\n  #   }\n  #\n  # })\n  #\n  output$testmerge <- DT::renderDataTable({\n\n    # a<- intData()\n    a<- dataMerge2()\n    # a <- indexmatrix()\n\n    # a <- rSu()\n\n\n\n    if(input$modtyp == 'sigmoid'){\n      if(input$incpd == TRUE){\n        DT::datatable(data.frame(GeneID = a$GeneID, RB50 = a$RB50Coef, RB50pval = a$RB50Pval,Topminusbottom = a$Top_minus_min ,correctedRB50 = a$correctedRB50, depletionConst = a$depletionConstant, Kinase = a$Kinase),\n                      options = list(scrollX = TRUE)  )\n      }else{\n        DT::datatable(data.frame(GeneID = a$GeneID, RB50 = a$RB50Coef, RB50pval = a$RB50Pval,Topminusbottom = a$Top_minus_min , Kinase = a$Kinase),\n                      options = list(scrollX = TRUE)  )\n      }\n\n    } else{\n      DT::datatable(data.frame(GeneID = a$GeneID.x, Intercept = signif(a$P.Value), Slope = signif(a$P.Value.x), Quadtratic = signif(a$P.Value.y), Kinase = a$Kinase),\n                    options = list(scrollX = TRUE)  )\n    }\n\n\n\n  })\n\n\n  output$kintab <- DT::renderDataTable({\n    data.merged <- dataMerge()\n\n    proteome<-as.vector(toupper(data.merged$GeneID))\n    DT::datatable(data.frame(GeneID = intersect(proteome,kinome)))\n  }\n\n  )\n\n  #################\n  ## OUTPUT download\n  #################\n\n  output$peprmv<- downloadHandler(\n    filename = function() {\n      paste(\"removedPep\", '.csv', sep='')\n    },\n    content = function(file) {\n      write.csv(pepdwn(), file)\n    }\n  )\n\n  output$report <- downloadHandler(\n    # For PDF output, change this to \"report.pdf\"\n    filename = \"report.html\",\n    content = function(file) {\n      # Copy the report file to a temporary directory before processing it, in\n      # case we don't have write permissions to the current working dir (which\n      # can happen when deployed).\n      tempReport <- file.path(tempdir(), \"report.Rmd\")\n      file.copy(\"report.Rmd\", tempReport, overwrite = TRUE)\n\n      # Set up parameters to pass to Rmd document\n      params <- list(chans = input$chans, reps = input$reps, data = dataMerge(), data2 = dataMerge2(), channel = channels(), avthrsli = input$avthrssli,\n                     pvalsli = input$pvalsli, indexmat = indexmatrix(), RSu = rSu(), finNam = finalNames(), datype = input$datype, sigmodin = input$modtyp, concen = sigConc(), sigPred = sigPredNames()\n                      ,\n                      vennip = input$venninput, kin = kinome1\n                      # , upVenn <- uploadVenn()\n                     )\n\n\n      # Knit the document, passing in the `params` list, and eval it in a\n      # child of the global environment (this isolates the code in the document\n      # from the code in this app).\n      rmarkdown::render(tempReport, output_file = file,\n                        params = params,\n                        envir = new.env(parent = globalenv())\n      )\n    }\n  )\n\n  DownloadData<- reactive({\n    data.merged <- dataMerge2()\n    if(input$modtyp != 'sigmoid'){\n       colnames(data.merged)[match(c('P.Value', 'adj.P.Val', 'P.Value.x', 'adj.P.Val.x', 'P.Value.y', 'adj.P.Val.y'),colnames(data.merged))] <- c( 'P.Value_slope', 'adj.P.Val_slope', 'P.Value_intercept', 'adj.P.Val_intercept','P.Value_quadratic', 'adj.P.Val_quadratic')\n    }\n    print(head(data.merged))\n    data.merged\n  })\n\n  output$downloadData <- downloadHandler(\n\n    filename = function() {\n      paste(input$dataset, '.csv', sep='')\n    },\n    content = function(file) {\n      write.csv(DownloadData(), file)\n    }\n  )\n\n  ## rest elements -- doesn't get rendered\n\n  output$testkd<- DT::renderDataTable({\n\n    # kd<- rKd()\n    #\n    # DT::datatable(data.frame(kd))\n      # a<- dataMerge2()\n       # a<- rSu()\n      # a<- uniprotGene()\n    a<- DownloadData()\n    DT::datatable(a,\n                  options = list(scrollX = TRUE) )\n  })\n\n  output$sessionInfo <- renderPrint({\n    capture.output(sessionInfo())\n  })\n\n})\n\n# Run the application\n\n\nshinyApp(ui = ui, server = server)\n",
    "created" : 1498301905866.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "1781|35|1787|10|\n1787|16|1792|10|\n1917|46|1923|8|\n1923|14|1929|8|\n2000|48|2007|10|\n2007|16|2014|10|\n2052|48|2058|10|\n2058|16|2063|10|\n2086|48|2092|10|\n2092|16|2097|10|\n",
    "hash" : "2247704800",
    "id" : "4F2ED84B",
    "lastKnownWriteTime" : 1498304873,
    "last_content_update" : 1498304873140,
    "path" : "~/Desktop/Doscheda/inst/shiny-examples/DOSCHEDA_app/app.R",
    "project_path" : "inst/shiny-examples/DOSCHEDA_app/app.R",
    "properties" : {
    },
    "relative_order" : 12,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}
{
    "collab_server" : "",
    "contents" : "#'@importFrom stats na.omit lm fitted predict median\n#'@import drc\nstandard_names<- function(chans, reps, dataType){\n  if(dataType == \"intensity\"){\n\n    tempNames <-   paste(\"rep\",rep(1:reps,each = chans),\"_\",\n                         rep(paste(\"C\",c(\"ontrol\",0:(chans - 2)), sep = \"\"),reps),sep = \"\")\n\n\n\n  }else{\n    tempNames <-  paste(\"rep\",rep(1:reps,each = chans),\"_\",\n                        rep(paste(\"C\",0:(chans - 1), sep = \"\"),reps),sep = \"\")\n\n  }\n  return(tempNames)\n}\n\n\nindex_matrix<- function(nchans, reps, dataType, dataFrame){\n\n  # reqtemp <- data()\n  # req(reqtemp)\n\n  if(reps <= 1){\n    NULL\n  } else {\n\n    if(dataType == \"intensity\"){\n      channe <- 1:((nchans - 1) * reps)\n      chans <- nchans - 1\n      ser <- standard_names(nchans,reps,dataType)\n      ser<- ser[-seq(1,by = nchans,length.out = reps)]\n\n    }else{\n      ser <- standard_names(nchans,reps,dataType)\n      channe <- 1:(nchans * reps)\n      chans <- nchans\n\n    }\n\n    combinations <- t(utils::combn(reps,2))\n    combmat<- matrix(rep(as.vector(t(combinations)),chans),ncol = 2,byrow = TRUE)\n\n    # create factor for repeat ...\n\n    name.vec <- 1:(chans*reps)\n    repfac <- rep(1:chans,times = reps)\n    index <- rep(0:(reps-1),each = chans)\n    combfac<- rep(1:(reps),each = chans)\n\n    # total combinations  = chans * nrow()\n    columnindex <- matrix(0 , ncol = 5 , nrow = chans * nrow(combinations) )\n\n    colnames(columnindex) <- c(\"concentration\",\"rep1\",\"rep2\",\"index1\",\"index2\")\n    columnindex[,1] <- rep(1:chans ,each = nrow(combinations))\n\n    columnindex[,2:3]<- combmat\n\n    columnindex\n    # create matrix which will be indexed by first 3 columns of column index\n\n    index.mat <- matrix(name.vec,ncol = reps)\n\n    for(i in 1:nrow(columnindex)){\n\n      columnindex[i,4] <- index.mat[columnindex[i,1],columnindex[i,2]]\n      columnindex[i,5] <- index.mat[columnindex[i,1],columnindex[i,3]]\n\n    }\n\n\n\n    create.names <- rep(\"\", nrow(columnindex))\n\n\n    for( i in 1:nrow(columnindex)){\n      create.names[i] <- paste(ser[columnindex[i,4]], \"vs\", ser[columnindex[i,5]])\n    }\n\n    final.mat <- data.frame(names = create.names,columnindex)\n    final.mat$concentration <- final.mat$concentration - 1\n    final.mat[!is.na(rowSums(matrix(match(columnindex,channe),ncol=5))),]\n  }\n\n}\n\n\npeptide_match <- function(dr1,dr2,nchan){\n  maxrow <- max(nrow(dr1),nrow(dr2))\n  minrow <- min(nrow(dr1),nrow(dr2))\n\n  adVal <- maxrow - minrow\n\n  if(nrow(dr1) == maxrow){\n    dr2$addedVals <- adVal\n    big.pep <- dr1\n    small.pep <- dr2\n  } else {\n    dr1$addedVals <- adVal\n    big.pep <- dr2\n    small.pep <- dr1\n  }\n\n\n  newframe <- big.pep\n  colnames(newframe) <- colnames(small.pep)\n  newframe[1:minrow,] <- small.pep\n\n  for(i in  1:nchan){\n\n    newframe[(minrow+1):maxrow,i]<- mean(small.pep[,i])\n  }\n\n\n  if (all.equal(dim(big.pep),dim(dr1)) == TRUE){\n\n    dr2 <- newframe\n  } else {\n    dr1 <- newframe\n  }\n\n  list(dr1 = dr1, dr2 = dr2 )\n}\n\n\nuniprotGene <- function(organism){\n\n\n  if(organism == 'H.sapiens'){\n    query = '<query model=\"genomic\" view=\"Protein.primaryAccession Protein.uniprotAccession Protein.genes.symbol\" sortOrder=\"Protein.primaryAccession ASC\" >\n    <constraint path=\"Protein.organism.shortName\" op=\"=\" value=\"H. sapiens\" code=\"A\" />\n    </query>'\n\n    ret = httr::POST('http://www.humanmine.org/humanmine/service/query/results',\n             body=list(query = query, format = 'json'),\n             encode='form')\n  } else if(organism == 'D.melanogaster'){\n\n    query = '<query model=\"genomic\" view=\"Protein.primaryAccession Protein.uniprotAccession Protein.genes.symbol\" sortOrder=\"Protein.primaryAccession ASC\" >\n    <constraint path=\"Protein.organism.shortName\" op=\"=\" value=\"D. melanogaster\" code=\"A\" />\n    </query>'\n\n    ret = httr::POST('http://www.flymine.org/flymine/service/query/results',\n             body=list(query=query, format='json'),\n             encode='form')\n\n  }else if(organism == 'M.musculus'){\n    query = '<query model=\"genomic\" view=\"Protein.primaryAccession Protein.uniprotAccession Protein.genes.symbol\" sortOrder=\"Protein.primaryAccession ASC\" >\n    <constraint path=\"Protein.organism.shortName\" op=\"=\" value=\"M. musculus\" code=\"A\" />\n    </query>'\n    ret = httr::POST('http://www.mousemine.org/mousemine/service/query/results',\n               body=list(query=query, format='json'),\n               encode='form')\n  }else if (organism == 'R.norvegicus'){\n    query = '<query model=\"genomic\" view=\"Protein.primaryAccession Protein.uniprotAccession Protein.genes.symbol\" sortOrder=\"Protein.primaryAccession ASC\" >\n    <constraint path=\"Protein.organism.shortName\" op=\"=\" value=\"R. norvegicus\" code=\"A\" />\n    </query>'\n\n    ret = httr::POST('http://www.ratmine.org/ratmine/service/query/results',\n               body=list(query = query, format='json'),\n               encode='form')\n  }else{\n    query = '<query model=\"genomic\" view=\"Protein.primaryAccession Protein.uniprotAccession Protein.genes.symbol\" sortOrder=\"Protein.primaryAccession ASC\" >\n    <constraint path=\"Protein.organism.shortName\" op=\"=\" value=\"C. elegans\" code=\"A\" />\n    </query>'\n\n    ret = httr::POST('http://www.humanmine.org/humanmine/service/query/results',\n             body=list(query=query, format='json'),\n             encode='form')\n  }\n\n  response = jsonlite::fromJSON(httr::content(ret,as='text'))\n\n  data.prots <- response$results[,c(1,3)]\n  colnames(data.prots) <- c('Entry','Gene.names')\n  as.data.frame(data.prots[,1:2],stringsAsFactors = FALSE)\n\n}\n\n\npanel_shadeNtext <- function (x, y, corr = NULL, col.regions, ...)\n{\n  if (is.null(corr))\n    corr <- stats::cor(x, y, use = \"\n                pair\")\n  ncol <- 14\n  pal <- col.regions(ncol)\n  col.ind <- as.numeric(cut(corr, breaks = seq(from = -1, to = 1,\n                                               length = ncol + 1), include.lowest = TRUE))\n  usr <- graphics::par(\"usr\")\n  graphics::rect(usr[1], usr[3], usr[2], usr[4], col = pal[col.ind],\n       border = NA)\n  graphics::box(col = \"lightgray\")\n  on.exit(graphics::par(usr))\n  graphics::par(usr = c(0, 1, 0, 1))\n  r <- formatC(corr, digits = 2, format = \"f\")\n  cex.cor <- .8/graphics::strwidth(\"-X.xx\")\n  graphics::text(0.5, 0.5, r, cex = cex.cor)\n}\n\nshape_for_ggplot_pred<-function(df_ordered,conc,pred.names){\n  cols_to_keep_pred<-c(pred.names,\"GeneID\",\"Accession\")\n\n  forggplot_pred<-vector(mode = \"list\",length = length(df_ordered$GeneID))\n\n  for(i in 1:length(df_ordered$GeneID)){\n    tmp_pred<-df_ordered[,cols_to_keep_pred]\n    forggplot_pred[[i]]<-reshape2::melt(tmp_pred[i,], id = c(\"GeneID\", \"Accession\"), na.rm = TRUE)\n  }\n\n  forggplot_pred_1<-do.call(rbind, forggplot_pred)\n  forggplot_pred_1<-data.frame(forggplot_pred_1,\"x\"=conc)\n  #return(forggplot_pred_1)\n}\n\nshape_for_ggplot_perc<-function(df_ordered,conc,finalNames){\n  cols_to_keep_perc<-c(finalNames, \"GeneID\",\"Accession\")\n\n  forggplot_perc<- vector(mode = \"list\",length = length(df_ordered$GeneID))\n  for(i in 1:length(df_ordered$GeneID)){\n    tmp_perc<-df_ordered[,cols_to_keep_perc]\n    forggplot_perc[[i]]<-reshape2::melt(tmp_perc[i,], id = c(\"GeneID\", \"Accession\"), na.rm = TRUE)\n  }\n\n  forggplot_perc_1<-do.call(rbind, forggplot_perc)\n  forggplot_perc_1<-data.frame(forggplot_perc_1,\"x\"=conc)\n  #return(forggplot_perc_1)\n}\n\nremove_peptides <- function(dataFrame, chans, reps, accessionID, chanNames, sequenceID, qualityID, incPDofPD, PDofPD, removePeptides, modelType,\n                            incGeneFile, geneFile){\n\n  tempdat <- dataFrame\n\n\n  # make matrix of descriptions and accessions to filter by common proteins\n\n  accDesMat <- as.character(tempdat[as.character(tempdat[,accessionID]) == \"\",c(accessionID)])\n\n  if(incPDofPD == TRUE){\n    data.merged <- tempdat[,c(chanNames, accessionID, sequenceID,qualityID,'pdofpd')]\n\n  }else{\n    data.merged <- tempdat[,c(chanNames, accessionID, sequenceID,qualityID)]\n  }\n\n  # need to make check if user has run the parameter function\n  if(chanNames[1] != \"Control_rep1\"){\n    channelnames <- standard_names(chans, reps, dataType = \"intensity\")\n  }\n  repindex <- rep(1:reps,each = chans)\n  totfal <- rep(FALSE , (chans + 3 ))\n\n  if(incPDofPD == TRUE){\n\n    newdf <- cbind(data.merged[,1:chans], data.merged[,c(accessionID, sequenceID,qualityID,PDofPD)])\n    colnames(newdf) <- c(channelnames[repindex  == 1],\"Accession\",\"Sequence\", \"Quality\",'Kd')\n    newdf <- newdf[!is.na(rowSums(newdf[,1:chans])),]\n    newdf <- newdf[newdf$Quality <= 0.05, ]\n    newdf <- data.frame(newdf, outliers = rep(0,length(newdf[,1])), uniquePeps = rep(0,length(newdf[,1])), addedVals = rep(0,length(newdf[,1])),Kd = newdf$Kd)\n\n\n  }else{\n    newdf <- cbind(data.merged[,1:chans], data.merged[,c(accessionID, sequenceID,qualityID)])\n    colnames(newdf) <- c(channelnames[repindex  == 1],\"Accession\",\"Sequence\", \"Quality\")\n    newdf <- newdf[!is.na(rowSums(newdf[,1:chans])),]\n    newdf <- newdf[newdf$Quality <= 0.05, ]\n  }\n\n  if(reps == 2){\n    channelnames <- paste(\"rep\",rep(1:reps,each = chans),\"_\",\n                          rep(paste(\"C\",c(\"ontrol\",0:(chans - 2)), sep = \"\"),reps),sep = \"\")\n    newdf2 <- cbind(data.merged[,(chans+1):(2*chans) ],data.merged[,c(accessionID, sequenceID,qualityID)])\n    colnames(newdf2) <- c(channelnames[repindex  == 2],\"Accession\",\"Sequence\",\"Quality\")\n    newdf2 <- newdf2[!is.na(rowSums(newdf2[,1:chans])),]\n    newdf2 <- newdf2[newdf2$Quality <= 0.05, ]\n\n\n\n    newdf <- data.frame(newdf, outliers = rep(0,length(newdf[,1])), uniquePeps = rep(0,length(newdf[,1])), addedVals = rep(0,length(newdf[,1])))\n    newdf2 <- data.frame(newdf2, outliers = rep(0,length(newdf2[,1])), uniquePeps = rep(0,length(newdf2[,1])), addedVals = rep(0,length(newdf2[,1])))\n\n\n    common.proteins <- intersect(unique(newdf$Accession),unique(newdf2$Accession))\n\n    newdf <- newdf[!is.na(match(newdf$Accession,common.proteins)),]\n    newdf2 <- newdf2[!is.na(match(newdf2$Accession,common.proteins)),]\n  }else{\n    common.proteins <- unique(newdf$Accession)\n  }\n\n\n\n  if(removePeptides == FALSE){\n\n    if(reps == 1 & modelType == 'sigmoid'){\n      if(incPDofPD == TRUE){\n        prot1 <- unique(newdf$Accession)\n        sumkd <- rep(0,length(prot1))\n        protdf<- newdf[1:length(prot1),colnames(newdf) != \"Sequence\"]\n        for(i in 1:length(prot1)){\n          ## grep for total intensity () includes non unique peps\n          protdf[i,1:chans] <- apply(newdf[grep(prot1[i],newdf$Accession),1:chans],2,sum,na.rm = TRUE)\n          protdf$Kd[i] <- sum(newdf$Kd[grep(prot1[i],newdf$Accession)],na.rm = TRUE)\n          protdf$Accession[i] <- prot1[i]\n\n          ## use == to get unique peptides per protein per repeat\n          # protdf$uniquePeps[i] <- length(unique(newdf$Sequence[newdf$Accession == prot1[i]]))\n          protdf$uniquePeps[i] <- length(unique(unique(newdf$Sequence[newdf$Accession == prot1[i]])))\n\n        }\n\n        protdf$uniquePeps[grep(\";\",protdf$Accession)] <- 0\n\n        fc1 <- protdf[,1] / protdf[,2:chans]\n\n        Kd <- protdf$Kd / protdf[,1]\n\n        fcprotdf <- data.frame(log2(fc1),\n                               Accession = protdf$Accession,uniquePepr1 = protdf$uniquePeps,\n                               uniquePepr2 =protdf$uniquePeps, Kd = Kd)\n        fcprotdf<- fcprotdf[!is.na(rowSums(fcprotdf[1:(chans - 1 )])),]\n        fcprotdf\n\n      }else{\n\n        prot1 <- unique(newdf$Accession)\n        protdf<- newdf[1:length(prot1),colnames(newdf) != \"Sequence\"]\n\n        for(i in 1:length(prot1)){\n          ## grep for total intensity () includes non unique peps\n          protdf[i,1:chans] <- apply(newdf[grep(prot1[i],newdf$Accession),1:chans],2,sum,na.rm = TRUE)\n          protdf$Accession[i] <- prot1[i]\n\n          ## use == to get unique peptides per protein per repeat\n          # protdf$uniquePeps[i] <- length(unique(newdf$Sequence[newdf$Accession == prot1[i]]))\n          protdf$uniquePeps[i] <- length(unique(unique(newdf$Sequence[newdf$Accession == prot1[i]])))\n\n        }\n\n        protdf$uniquePeps[grep(\";\",protdf$Accession)] <- 0\n\n        fc1 <- protdf[,1] / protdf[,2:chans]\n\n\n        fcprotdf <- data.frame(log2(fc1),\n                               Accession = protdf$Accession,uniquePepr1 = protdf$uniquePeps,\n                               uniquePepr2 =protdf$uniquePeps)\n        fcprotdf<- fcprotdf[!is.na(rowSums(fcprotdf[1:(chans - 1 )])),]\n        fcprotdf\n\n      }\n\n\n    }else{\n      prot1 <- unique(newdf$Accession)\n      protdf<- newdf[1:length(prot1),colnames(newdf) != \"Sequence\"]\n\n\n      for(i in 1:length(prot1)){\n        ## grep for total intensity () includes non unique peps\n        protdf[i,1:chans] <- apply(newdf[grep(prot1[i],newdf$Accession),1:chans],2,sum,na.rm = TRUE)\n\n        protdf$Accession[i] <- prot1[i]\n\n        ## use == to get unique peptides per protein per repeat\n        # protdf$uniquePeps[i] <- length(unique(newdf$Sequence[newdf$Accession == prot1[i]]))\n        protdf$uniquePeps[i] <- length(unique(c(unique(newdf$Sequence[newdf$Accession == prot1[i]]),unique(newdf2$Sequence[newdf2$Accession == prot1[i]]))))\n\n      }\n\n      protdf$uniquePeps[grep(\";\",protdf$Accession)] <- 0\n\n\n      prot2 <- unique(newdf2$Accession)\n      ### second data frame\n\n      protdf2<- newdf2[1:length(prot2),colnames(newdf2) != \"Sequence\"]\n\n      for(i in 1:length(prot2)){\n\n        ## grep for total intensity () includes non unique peps\n        protdf2[i,1:chans] <- apply(newdf2[grep(prot2[i],newdf2$Accession),1:chans],2,stats::median,na.rm = TRUE)\n        protdf2$Accession[i] <- prot2[i]\n\n        ## use == to get unique peptides per protein per repeat\n        protdf2$uniquePeps[i] <- length(unique(newdf2$Sequence[newdf2$Accession == prot2[i]]))\n      }\n\n      protdf2$uniquePeps[grep(\";\",protdf2$Accession)] <- 0\n\n\n      com.prot <- intersect(protdf$Accession,protdf2$Accession)\n\n      fc1 <- protdf[,1] / protdf[,2:chans]\n      fc2 <-  protdf2[,1] / protdf2[,2:chans]\n\n\n      fcprotdf <- data.frame(log2(fc1[match(com.prot,protdf$Accession),]),\n                             log2(fc2[match(com.prot,protdf2$Accession),]),\n                             Accession = com.prot,uniquePepr1 = protdf$uniquePeps[match(com.prot,protdf$Accession)],\n                             uniquePepr2 =protdf2$uniquePeps[match(com.prot,protdf2$Accession)])\n      fcprotdf<- fcprotdf[!is.na(rowSums(fcprotdf[1:(reps*chans -2 )])),]\n      fcprotdf\n    }\n\n\n  }else{\n\n    totpepdf <- NULL\n    totpepdf2 <- NULL\n\n    for (z in 1:length(common.proteins)){\n      temp <- newdf[newdf$Accession == common.proteins[z],]\n      temp2 <- newdf2[newdf2$Accession == common.proteins[z],]\n      # first step: check if all peptides are unique ...\n\n      if(all.equal(grep(\";\",temp$Accession),integer(0)) == TRUE){\n\n        uniPeptides1 <- length(unique(temp$Sequence))\n\n      }  else {\n        uniPeptides1 <- length(unique(temp$Sequence[-grep(\";\",temp$Accession)]))\n      }\n\n      if(all.equal(grep(\";\",temp2$Accession),integer(0)) == TRUE){\n\n        uniPeptides2 <- length(unique(temp2$Sequence))\n\n      }else{\n\n        uniPeptides2 <- length(unique(temp2[-grep(\";\",temp2$Accession)]))\n      }\n\n      ## add unique peptide column\n\n      temp$uniquePeps <- uniPeptides1\n      temp2$uniquePeps <- uniPeptides2\n\n\n      tempPep <- intersect(unique(temp$Sequence),unique(temp2$Sequence))\n\n\n      if(all.equal(tempPep, character(0)) == TRUE){\n        next\n      }\n\n      for(i in 1:length(tempPep)){\n\n        if(sum(temp$Sequence == tempPep[i]) != sum(temp2$Sequence == tempPep[i])){\n\n          dr <- peptide_match(temp[temp$Sequence == tempPep[i],],temp2[temp2$Sequence == tempPep[i],],chans)\n          dr1 <- dr$dr1\n          dr2 <- dr$dr2\n\n        } else {\n\n          dr1 <- temp[temp$Sequence == tempPep[i],]\n          dr2 <- temp2[temp2$Sequence == tempPep[i],]\n\n\n        }\n\n        tempoindex <- rep(FALSE,nrow(dr1))\n        for(j in 1:nrow(dr1)){\n          percor <- stats::cor.test(log2(as.numeric(dr1[j,1:chans])),log2(as.numeric(dr2[j,1:chans])))\n          tempoindex[j] <- percor$estimate < 0.4\n        }\n\n        dr1[tempoindex,1:chans] <- NA\n        dr2[tempoindex,1:chans] <- NA\n\n\n\n        tempReplace <- dr1\n        tempReplace2 <- dr2\n\n\n\n        temp <- temp[temp$Sequence != tempPep[i],]\n        temp <- rbind(temp,tempReplace)\n\n        temp2 <- temp2[temp2$Sequence != tempPep[i],]\n        temp2 <- rbind(temp2,tempReplace2)\n\n      }\n\n      temp<- temp[match(tempPep,temp$Sequence),]\n      temp2<- temp2[match(tempPep,temp2$Sequence),]\n\n      totpepdf <- rbind(totpepdf,temp)\n\n\n      totpepdf2 <- rbind(totpepdf2,temp2)\n    }\n\n\n\n\n    totpepdf<- totpepdf[!is.na(rowSums(totpepdf[,1:chans])),]\n    totpepdf2<- totpepdf2[!is.na(rowSums(totpepdf2[,1:chans])),]\n\n    totpepdf<- totpepdf[totpepdf$addedVals == 0, ]\n    totpepdf<- totpepdf[totpepdf$addedVals == 0, ]\n\n\n    totpepdf$uniquePeps[grep(';',totpepdf$Accession)] <- 0\n\n\n    ### take sums\n\n    pepframe<- data.frame(totpepdf[1:length(common.proteins),1:chans],totpepdf2[1:length(common.proteins),1:chans],\n                          Accession = totpepdf$Accession[1:length(common.proteins)], uniquePeps = totpepdf$uniquePeps[1:length(common.proteins)])\n\n    pepsum1 <- pepsum2 <- totpepdf[1:length(common.proteins),]\n    pepsum1 <- pepsum1[,-match(c(\"Sequence\",\"addedVals\", \"Quality\",\"outliers\"),colnames(pepsum1))]\n    pepsum2 <- pepsum2[,-match(c(\"Sequence\",\"addedVals\", \"Quality\",\"outliers\"),colnames(pepsum2))]\n\n    pepsum1$pepNum <- pepsum1$pepNum <- rep(0,length(common.proteins))\n\n\n    colnames(pepsum2)[1:chans]<- channelnames[(chans+1):(chans*reps)]\n\n    for(i in 1:length(common.proteins)){\n      pepsum1[i,1:chans] <- colSums(totpepdf[grep(common.proteins[i],totpepdf$Accession),1:chans])\n      pepsum2[i,1:chans] <- colSums(totpepdf2[grep(common.proteins[i],totpepdf2$Accession),1:chans])\n\n      pepsum1$pepNum[i] <- nrow(totpepdf[grep(common.proteins[i],totpepdf$Accession),1:chans])\n      pepsum2$pepNum[i] <- nrow(totpepdf2[grep(common.proteins[i],totpepdf2$Accession),1:chans])\n\n\n      pepsum1$Accession[i]<- pepsum2$Accession[i] <- common.proteins[i]\n      pepsum1$uniquePeps[i]<- totpepdf$uniquePeps[as.logical(match(totpepdf$Accession,common.proteins[i],nomatch = FALSE))][1]\n\n\n\n\n\n    }\n\n    indexpepsum <- ((rowSums(pepsum1[1:chans]) != 0) + ((rowSums(pepsum2[1:chans])) != 0)) == 2\n    pepsum1<- pepsum1[indexpepsum, ]\n    pepsum2<- pepsum2[indexpepsum, ]\n\n\n\n    fc1 <- pepsum1[,1] / pepsum1[,2:chans]\n    fc2 <- pepsum2[,1] / pepsum2[,2:chans]\n\n\n    fcprotdf <- data.frame(log2(fc1),log2(fc2),pepsum1$Accession,uniquePepr1 = pepsum1$uniquePeps,\n                           uniquePepr2 = pepsum2$uniquePeps,num1 =  pepsum1$pepNum, num2 = pepsum2$pepNum )\n\n\n    fcprotdf\n\n  }\n  fcprotdf\n}\n\nnormalize_data <- function(dataFrame, chans, reps,  PD2, channelNames,incPDofPD, PDofPD, removePeptides, dataType, modelType, incGeneFile = FALSE,\n                           conversionTable = NA, normaliseData = 'median', accessionID = NA, uniquePeptides = NA, organism = 'H.sapiens'){\n\n  inten <- dataFrame\n  channelIndex<- 1:(reps*chans)\n  if(dataType != \"intensity\"){\n\n    if(modelType == \"sigmoid\"){\n\n        data_orig2 <- dataFrame\n\n      ## if user has specified accession & Description\n      if(PD2 == TRUE){\n        pattern<-\"GN=(\\\\S+)\"\n        g_fromD1<- stringr::str_extract(data_orig2$Description,pattern)\n        gID_D1a<- stringr::str_split_fixed(g_fromD1,\"GN=\",n=2)\n        gID_D1a<-as.vector(gID_D1a[,2])\n        gID_D1<-as.matrix(replace(gID_D1a,gID_D1a==\"\",\"NA\"))\n        #Addition of the gene ID column\n        data_orig2[\"geneID\"]<- (gID_D1)\n\n      }else{\n\n        if(incGeneFile == FALSE){\n\n          tempacc <- data_orig2[,accessionID]\n          data_orig2 <- data_orig2[,(-accessionID)]\n          data_orig2$Accession <- tempacc\n          uniGene <- uniprotGene(organism)\n          # uniGene$Gene.names <- gsub(' .*','',uniGene$Gene.names)\n          uniGene$Gene.names[uniGene$Gene.names == '']<- NA\n          GeneID <- uniGene$Gene.names[match(data_orig2$Accession,uniGene$Entry)]\n          GeneID <- make.names(GeneID,unique = TRUE)\n\n          data_orig2$geneID <- GeneID\n        }else{\n\n          tempacc <- data_orig2[,accessionID]\n          data_orig2 <- data_orig2[,(-accessionID)]\n          data_orig2$Accession <- tempacc\n\n          uniGene <- conversionTable\n          GeneID <- uniGene$Gene.names[match(data_orig2$Accession,uniGene$Entry)]\n          GeneID <- make.names(GeneID,unique = TRUE)\n\n          data_orig2$geneID <- GeneID\n\n        }\n      }\n\n      if(incPDofPD == TRUE){\n\n        if(PD2 == TRUE){\n          data.merged<-data.frame(data_orig2[,channelNames],\n\n                                  data_orig2$Accession, data_orig2$geneID,\n                                  data_orig2$X..Unique.Peptides,data_orig2[,PDofPD])\n        }else{\n          data.merged<-data.frame(data_orig2[,channelNames],\n\n                                  data_orig2$Accession, data_orig2$geneID,\n                                  data_orig2[,uniquePeptides],data_orig2[,PDofPD])\n        }\n        final.Names <- standard_names(chans, reps, dataType)\n        colnames(data.merged)<- c(final.Names,\n                                  \"Accession\", \"GeneID\",\"UniquePeps\",'Kd')\n\n\n        tmp<-data.merged[,1:chans]\n        tf <- as.data.frame(lapply(tmp, function(x) (is.na(x))))\n        countsNAs<-as.data.frame(apply(tf,1,function(x)table(x)[\"TRUE\"]))\n        n_of_miss<-as.data.frame(as.numeric(stringr::str_replace_all(as.list(countsNAs[,1]),\"NA\",\"0\")))\n        data.merged <- data.frame(data.merged,n_of_miss)\n        colnames(data.merged)<-c( final.Names,\n                                  \"Accession\", \"GeneID\",\"UniquePeps\",'Kd', \"MissingVal\")\n        #\n        missing_val <- 0\n        #\n        data.merged<- as.data.frame(data.merged[data.merged$MissingVal <= missing_val, ])\n        #\n        # #Specify the number of missing points.For zero missing point  is ==0\n        #\n        # #filiter for 2 unique peptides\n        data.merged <- data.merged[data.merged$UniquePeps > 1, ]\n        #\n        #\n        if(normaliseData == 'loess'){\n\n          data.merged <- data.frame((affy::normalize.loess(2^(data.merged[,channelIndex]))),\n                                    Accession=data.merged$Accession,\n                                    GeneID=data.merged$GeneID,\n                                    UniquePeps=data.merged$UniquePeps,\n                                    Kd = 1 / data.merged$Kd,\n                                    MissingVal=data.merged$MissingVal)\n        } else if(normaliseData == 'median'){\n\n          data.merged <- data.frame(((2^(data.merged[,channelIndex])) /\n                                       apply((2^(data.merged[,channelIndex])),2,stats::median)),\n                                    Accession=data.merged$Accession,\n                                    GeneID=data.merged$GeneID,\n                                    UniquePeps=data.merged$UniquePeps,\n                                    Kd = 1 / data.merged$Kd,\n                                    MissingVal=data.merged$MissingVal)\n\n\n        }else{\n          data.merged <- data.frame((2^(data.merged[,channelIndex])),\n                                    Accession=data.merged$Accession,\n                                    GeneID=data.merged$GeneID,\n                                    UniquePeps=data.merged$UniquePeps,\n                                    Kd = 1 / data.merged$Kd,\n                                    MissingVal=data.merged$MissingVal)\n        }\n\n        data.merged\n\n      } else {\n        if(PD2 == TRUE){\n          data.merged<-data.frame(data_orig2[,channelNames],\n\n                                  data_orig2$Accession, data_orig2$geneID,\n                                  ## may need changing ...\n                                  data_orig2$X..Unique.Peptides)\n\n        }else{\n          data.merged<-data.frame(data_orig2[,channelNames],\n\n                                  data_orig2$Accession, data_orig2$geneID,\n                                  data_orig2[,uniquePeptides])\n        }\n        final.Names <- standard_names(chans , reps, 'LFC')\n\n        colnames(data.merged)<- c(final.Names,\n                                  \"Accession\", \"GeneID\",\"UniquePeps\")\n\n\n        tmp<-data.merged[,1:chans]\n        tf <- as.data.frame(lapply(tmp, function(x) (is.na(x))))\n        countsNAs<-as.data.frame(apply(tf,1,function(x)table(x)[\"TRUE\"]))\n        n_of_miss<-as.data.frame(as.numeric(stringr::str_replace_all(as.list(countsNAs[,1]),\"NA\",\"0\")))\n        data.merged <- data.frame(data.merged,n_of_miss)\n        colnames(data.merged)<-c( final.Names,\n                                  \"Accession\", \"GeneID\",\"UniquePeps\",\"MissingVal\")\n        #\n        missing_val <- 0\n        #\n        data.merged<- as.data.frame(data.merged[data.merged$MissingVal <= missing_val, ])\n        #\n        # #Specify the number of missing points.For zero missing point  is ==0\n        #\n        # #filiter for 2 unique peptides\n        data.merged <- data.merged[data.merged$UniquePeps > 1, ]\n        #\n        #\n        if(normaliseData == 'loess'){\n\n          data.merged <- data.frame((affy::normalize.loess(2^(data.merged[,channelIndex]))),\n                                    Accession=data.merged$Accession,\n                                    GeneID=data.merged$GeneID,\n                                    UniquePeps=data.merged$UniquePeps,\n                                    MissingVal=data.merged$MissingVal)\n\n        }else if(normaliseData == 'median'){\n\n          data.merged <- data.frame(((2^(data.merged[,channelIndex])) /\n                                       apply((2^(data.merged[,channelIndex])),2,stats::median)),\n                                    Accession=data.merged$Accession,\n                                    GeneID=data.merged$GeneID,\n                                    UniquePeps=data.merged$UniquePeps,\n                                    MissingVal=data.merged$MissingVal)\n\n        }else{\n          data.merged <- data.frame((2^(data.merged[,channelIndex])),\n                                    Accession=data.merged$Accession,\n                                    GeneID=data.merged$GeneID,\n                                    UniquePeps=data.merged$UniquePeps,\n                                    MissingVal=data.merged$MissingVal)\n        }\n        data.merged\n      }\n\n    } else {\n\n        tempdat <- dataFrame\n\n\n      temp<- channelIndex\n      nvec <- length(temp)\n\n      data.merged <- tempdat[,channelNames]\n      colnames(data.merged) <- standard_names(chans,reps,dataType)\n\n      data.names<- c(colnames(data.merged),\"Accession\", \"GeneID\",\"UniquePeps\",\"MissingVal\")\n\n      if(dataType == \"FC\"){\n        data.merged[,temp] <- log2(data.merged[,temp])\n      }\n      #tidy below !!\n\n      if(PD2 == TRUE){\n\n\n        pattern<-\"GN=(\\\\S+)\"\n        g_fromD1<- stringr::str_extract(tempdat$Description,pattern)\n        gID_D1a<- stringr::str_split_fixed(g_fromD1,\"GN=\",n=2)\n        gID_D1a<-as.vector(gID_D1a[,2])\n        gID_D1<-as.matrix(replace(gID_D1a,gID_D1a==\"\",\"NA\"))\n\n        Accession <- tempdat$Accession\n        UniquePeps <- MissingVal<- tempdat[,grep(\"Unique\",colnames(tempdat))]\n        data.merged <- cbind(data.merged,Accession, GeneID = gID_D1,UniquePeps,MissingVal)\n\n      } else {\n\n        tempdat$Accession <- tempdat[,accessionID]\n        if(incGeneFile == FALSE){\n\n          uniGene <- uniprotGene(organism)\n          # uniGene<- as.data.frame(uniGene,stringsAsFactors = FALSE)\n          # uniGene$Gene.names <- gsub(' .*','',uniGene$Gene.names)\n        } else{\n          uniGene <- conversionTable\n          colnames(uniGene)[1:2] <- c('Entry','Gene.names')\n        }\n        # uniGene$Gene.names[uniGene$Gene.names == '']<- NA\n        GeneID <- uniGene$Gene.names[match(tempdat$Accession,uniGene$Entry)]\n        GeneID <- make.names(GeneID,unique = TRUE)\n\n        Accession <- tempdat$Accession\n        UniquePeps <- MissingVal<- tempdat[,uniquePeptides]\n\n        # data_orig2$geneID <- GeneID\n        data.merged <- cbind(data.merged,Accession, GeneID = GeneID,UniquePeps,MissingVal)\n      }\n\n\n      channelIndex<- 1:(reps*chans)\n      missing<- rowSums(is.na(data.merged[,channelIndex]))\n\n      missing_val <- 0\n      data.merged$MissingVal <- missing\n\n      ## subset by missing\n      data.merged <- data.merged[data.merged$MissingVal <= missing_val, ]\n      data.merged<- as.data.frame(data.merged[data.merged$MissingVal <= missing_val, ])\n\n      data.merged <- data.merged[data.merged$UniquePeps > 1, ]\n      #\n      #\n      if(normaliseData == 'loess'){\n\n        data.merged <- data.frame(log2(affy::normalize.loess(2^(data.merged[,channelIndex]))),\n                                  Accession=data.merged$Accession,\n                                  GeneID=data.merged$GeneID,\n                                  UniquePeps=data.merged$UniquePeps,\n                                  MissingVal=data.merged$MissingVal)\n\n      }else if(normaliseData == 'median'){\n\n        data.merged <- data.frame(log2((2^(data.merged[,channelIndex])) /\n                                         apply((2^(data.merged[,channelIndex])),2,stats::median)),\n                                  Accession=data.merged$Accession,\n                                  GeneID=data.merged$GeneID,\n                                  UniquePeps=data.merged$UniquePeps,\n                                  MissingVal=data.merged$MissingVal)\n\n      } else {\n        data.merged <- data.frame(log2((2^(data.merged[,channelIndex]))),\n                                  Accession=data.merged$Accession,\n                                  GeneID=data.merged$GeneID,\n                                  UniquePeps=data.merged$UniquePeps,\n                                  MissingVal=data.merged$MissingVal)\n\n      }\n\n\n      data.merged\n      ## filter for 2 unique peptide\n    }\n\n  } else {\n\n    ### intensities to protein done.. here no description so we need toi use accession and intermine\n\n    tempdat <- inten\n\n    if(incGeneFile == FALSE){\n\n      uniGene <- uniprotGene(organism)\n      # uniGene$Gene.names <- gsub(' .*','',uniGene$Gene.names)\n    }else{\n      uniGene <- conversionTable\n      colnames(uniGene) <- c('Entry','Gene.names')\n    }\n\n    if(removePeptides == TRUE){\n\n      Accession <- tempdat$pepsum1.Accession\n    }else{\n      Accession <- tempdat$Accession\n    }\n    uniGene$Gene.names[uniGene$Gene.names == '']<- NA\n    GeneID <- uniGene$Gene.names[match(Accession,uniGene$Entry)]\n    GeneID <- make.names(GeneID,unique = TRUE)\n\n    tempdat$GeneID <- GeneID\n\n    UniquePeps <- tempdat$uniquePepr1\n\n    if(reps == 1){\n\n      data.merged <- tempdat\n      final.Names <- paste0('rep1_C',0:(chans - 2))\n      if(incPDofPD == TRUE){\n\n        data.merged <- data.frame(data.merged[,1:(chans -1 )], Accession = data.merged$Accession,\n                                  GeneID = data.merged$GeneID, UniquePeps = data.merged$uniquePepr1, Kd = data.merged$Kd)\n        colnames(data.merged)<- c(final.Names,\n                                  \"Accession\", \"GeneID\",\"UniquePeps\", 'Kd')\n\n        tmp<-data.merged[,1:(chans -1 )]\n        tf <- as.data.frame(lapply(tmp, function(x) (is.na(x))))\n        countsNAs<-as.data.frame(apply(tf,1,function(x)table(x)[\"TRUE\"]))\n        n_of_miss<-as.data.frame(as.numeric(stringr::str_replace_all(as.list(countsNAs[,1]),\"NA\",\"0\")))\n        data.merged <- data.frame(data.merged,n_of_miss)\n        colnames(data.merged)<-c( final.Names,\n                                  \"Accession\", \"GeneID\",\"UniquePeps\",'Kd',\"MissingVal\")\n        #\n        missing_val <- 0\n        #\n        data.merged<- as.data.frame(data.merged[data.merged$MissingVal <= missing_val, ])\n        #\n        # #Specify the number of missing points.For zero missing point  is ==0\n        #\n        # #filiter for 2 unique peptides\n        data.merged <- data.merged[data.merged$UniquePeps > 1, ]\n        #\n        #\n        if(normaliseData == 'loess'){\n\n          data.merged <- data.frame((affy::normalize.loess(2^(data.merged[,1:(chans -1)]))),\n                                    Accession=data.merged$Accession,\n                                    GeneID=data.merged$GeneID,\n                                    UniquePeps=data.merged$UniquePeps,\n                                    Kd = data.merged$Kd\n          )\n        }else if (normaliseData == 'median'){\n          data.merged <- data.frame(((2^(data.merged[,1:(chans -1)]))/\n                                       apply((2^(data.merged[,1:(chans -1)])),2,stats::median)),\n                                    Accession=data.merged$Accession,\n                                    GeneID=data.merged$GeneID,\n                                    UniquePeps=data.merged$UniquePeps,\n                                    Kd = data.merged$Kd\n          )\n\n        }else{\n          data.merged <- data.frame((2^(data.merged[,1:(chans -1)])),\n                                    Accession=data.merged$Accession,\n                                    GeneID=data.merged$GeneID,\n                                    UniquePeps=data.merged$UniquePeps,\n                                    Kd = data.merged$Kd\n          )\n        }\n\n\n        data.merged\n\n      } else {\n\n        data.merged <- data.frame(data.merged[,1:(chans -1 )], Accession = data.merged$Accession,\n                                  GeneID = data.merged$GeneID, UniquePeps = data.merged$uniquePepr1)\n        colnames(data.merged)<- c(final.Names,\n                                  \"Accession\", \"GeneID\",\"UniquePeps\")\n\n\n        tmp<-data.merged[,1:(chans -1 )]\n        tf <- as.data.frame(lapply(tmp, function(x) (is.na(x))))\n        countsNAs<-as.data.frame(apply(tf,1,function(x)table(x)[\"TRUE\"]))\n        n_of_miss<- as.data.frame(as.numeric(stringr::str_replace_all(as.list(countsNAs[,1]),\"NA\",\"0\")))\n        data.merged <- data.frame(data.merged,n_of_miss)\n        colnames(data.merged)<-c( final.Names,\n                                  \"Accession\", \"GeneID\",\"UniquePeps\",\"MissingVal\")\n        #\n        missing_val <- 0\n        #\n        data.merged<- as.data.frame(data.merged[data.merged$MissingVal <= missing_val, ])\n        #\n        # #Specify the number of missing points.For zero missing point  is ==0\n        #\n        # #filiter for 2 unique peptides\n        data.merged <- data.merged[data.merged$UniquePeps > 1, ]\n        #\n        #\n        if(normaliseData == 'loess'){\n\n          data.merged <- data.frame((affy::normalize.loess(2^(data.merged[,1:(chans -1)]))),\n                                    Accession=data.merged$Accession,\n                                    GeneID=data.merged$GeneID,\n                                    UniquePeps=data.merged$UniquePeps)\n\n        }else if(normaliseData == 'median'){\n          data.merged <- data.frame(((2^(data.merged[,1:(chans -1)])) /\n                                       apply((2^(data.merged[,1:(chans -1)])),2,stats::median)),\n                                    Accession=data.merged$Accession,\n                                    GeneID=data.merged$GeneID,\n                                    UniquePeps=data.merged$UniquePeps)\n        }else{\n          data.merged <- data.frame((2^(data.merged[,1:(chans -1)])),\n                                    Accession=data.merged$Accession,\n                                    GeneID=data.merged$GeneID,\n                                    UniquePeps=data.merged$UniquePeps)\n\n        }\n\n        data.merged\n      }\n\n    } else{\n\n      data.merged <- tempdat[,1:((chans-1)*reps )]\n\n      data.merged <- tempdat[,1:((chans-1)*reps)]\n\n      if( removePeptides == FALSE){\n        Accession <- tempdat$Accession\n        MissingVal <- UniquePeps\n        data.merged <- cbind(data.merged,Accession, GeneID = GeneID,UniquePeps,MissingVal)\n\n        data.merged <- data.merged[!is.na(rowSums(data.merged[,1:((chans - 1)*reps)])),]\n        data.merged <- data.merged[data.merged$UniquePeps > 1, ]\n\n        data.merged <- data.frame((log2(affy::normalize.loess(2^(data.merged[,1:((chans - 1)*reps)])))),\n                                  Accession=data.merged$Accession,\n                                  GeneID=data.merged$GeneID,\n                                  UniquePeps=data.merged$UniquePeps)\n\n        data.merged <- data.merged[!is.na(rowSums(data.merged[,1:((chans - 1)*reps)])),]\n        data.merged\n      }else{\n\n        Accession <- tempdat$pepsum1.Accession\n        data.merged <- cbind(data.merged,Accession, GeneID = GeneID,UniquePeps, num1 = tempdat$num1, num2 = tempdat$num2)\n\n\n        data.merged <- data.merged[!is.na(rowSums(data.merged[,1:((chans - 1)*reps)])),]\n        data.merged <- data.merged[data.merged$UniquePeps > 1, ]\n\n        data.merged <- data.frame((log2(affy::normalize.loess(2^(data.merged[,1:((chans - 1)*reps)])))),\n                                  Accession=data.merged$Accession,\n                                  GeneID=data.merged$GeneID,\n                                  UniquePeps=data.merged$UniquePeps, num1 = data.merged$num1, num2 = data.merged$num2)\n\n        data.merged <- data.merged[data.merged$num1 > 1 | data.merged$num2 > 1 , ]\n        data.merged <- data.merged[!is.na(rowSums(data.merged[,1:((chans - 1)*reps)])),]\n        data.merged\n      }\n\n    }\n\n\n  }\n\n\n  data.merged\n\n}\n\nfit_model <- function(dataFrame , chans, reps, dataType = 'LFC', modelType = 'sigmoid', sigmoidConc = NA,  PD2 = TRUE,incPDofPD = FALSE, PDofPD = NA){\n\n  if(modelType == \"sigmoid\"){\n    if(dataType == 'intensity'){\n      nvec <- 1:(chans -1)\n      nvec <- length(nvec)\n      data.merged <- dataFrame\n\n      conc <- sigmoidConc\n      if(incPDofPD == TRUE){\n\n        final.Names <- paste0('rep1_C',0:(chans - 2 ))\n        pred.names <- paste0('predX',1:(chans -1))\n        colnames(data.merged[,1:(chans -1)]) <- final.Names\n        data_merged_positives<- data.merged\n        # na.omit(data.merged[data.merged[,1:chans] >= 1,])\n\n        data_merged_positives2<-( (1/data_merged_positives[,1:(chans -1 )]))*100\n        Reps_FC<-data.frame(data_merged_positives2 ,\n                            Accession =  data_merged_positives$Accession,GeneID = data_merged_positives$GeneID,\n                            UniquePeps = data_merged_positives$UniquePeps, depletionConstant = data_merged_positives$Kd\n        )\n\n\n        ryegrass.m1<- vector(mode = \"list\",length = nrow(Reps_FC))\n        pvals<- vector(mode = \"list\",length = nrow(Reps_FC))\n        stderr<- vector(mode = \"list\",length = nrow(Reps_FC))\n        model_pred<- vector(mode = \"list\",length = nrow(Reps_FC))\n        coeff_predicted<- vector(mode = \"list\",length = nrow(Reps_FC))\n        for(i in 1:nrow(Reps_FC)){\n          #print(i)\n\n          #nrow(full_df_2)\n          #maxIt and relTol to be user defined\n          ryegrass.m1[[i]]<-try(drc::drm(as.numeric(Reps_FC[i,1:(chans - 1 )]) ~ as.numeric(conc),\n                                         na.action = stats::na.omit,\n                                         control = drc::drmc(constr = FALSE, errorm = FALSE, noMessage = TRUE, maxIt = 1000, relTol = 1e-06),\n                                         fct = drc::LL.4(fixed=c(NA, NA, NA, NA), #see note @top this file\n                                                         names = c(\"Slope\", \"Lower Limit\", \"Upper Limit\", \"RB50\"))),silent = TRUE)\n\n        }\n\n        failed_sigm=0\n        for(i in 1:length(ryegrass.m1)){\n          #print(i)\n          #checking_val if FALSE  the model has failed to calculate the pval\n          checking_val<-try(is.numeric(vsn::coefficients(ryegrass.m1[[i]])[[\"Slope:(Intercept)\"]]),silent = TRUE)\n\n          if(checking_val==\"TRUE\"){\n            #print(checking_val)\n            pvals[[i]]<-t(as.data.frame(summary(ryegrass.m1[[i]])$coefficients[13:16]))\n            colnames(pvals[[i]])<-c(\"SlopePval\", \"Lower_LimitPval\", \"Upper_LimitPval\", \"RB50Pval\")\n            coeff_predicted[[i]]<-t(data.frame(vsn::coefficients(ryegrass.m1[[i]])))\n            colnames(coeff_predicted[[i]])<-c(\"SlopeCoef\", \"Lower_LimitCoef\", \"Upper_LimitCoef\",\"RB50Coef\")\n            stderr[[i]]<-t(as.data.frame(summary(ryegrass.m1[[i]])$coefficients[5:8]))\n            colnames(stderr[[i]])<-c(\"SlopeErr\", \"Lower_LimitErr\", \"Upper_LimitErr\",\"RB50Err\")\n\n            model_pred[[i]]<-predict(ryegrass.m1[[i]])\n          }else{\n            failed_sigm=failed_sigm+1\n\n            fit <- stats::lm(as.numeric(Reps_FC[i,1:(chans -1)]) ~ poly(log10(conc),2 ))\n            #extract the pval\n            pval<-as.numeric(summary(fit)$coefficients[,4] )\n            pvals[[i]]<- t(as.data.frame(c(pval,\"lm-fit:intercept.slope.quadratic\") ))\n            colnames(pvals[[i]])<-c(\"SlopePval\", \"Lower_LimitPval\", \"Upper_LimitPval\",\"RB50Pval\")\n            stderr[[i]]<- data.frame(NA,NA,NA,NA)\n            colnames(stderr[[i]])<-c(\"SlopeErr\", \"Lower_LimitErr\", \"Upper_LimitErr\",\"RB50Err\")\n            coeff_predicted[[i]]<-data.frame(NA,NA,NA,NA)\n            colnames(coeff_predicted[[i]])<-c(\"SlopeCoef\", \"Lower_LimitCoef\", \"Upper_LimitCoef\",\"RB50Coef\")\n            model_pred[[i]]<- as.numeric(stats::fitted(fit))\n          } #just adding NAs for the times the model failed\n        }\n\n\n        modelsReps<-data.frame(\n          do.call(rbind.data.frame,lapply(model_pred,function(x) as.numeric(x))),\n          Reps_FC$GeneID,\n          do.call(rbind.data.frame,lapply(pvals,function(x) x) ),\n          do.call(rbind.data.frame,lapply(coeff_predicted,function(x) x)) ,\n          do.call(rbind.data.frame,lapply(stderr,function(x) x) )\n        )\n        colnames(modelsReps)<-c(pred.names,\"GeneID\",\n                                \"SlopePval\", \"Lower_LimitPval\",\"Upper_LimitPval\", \"RB50Pval\",\n                                \"SlopeCoef\", \"Lower_LimitCoef\",\"Upper_LimitCoef\", \"RB50Coef\",\n                                \"SlopeErr\", \"Lower_LimitErr\",\"Upper_LimitErr\", \"RB50Err\"\n        )\n\n        data_merged_2 <- merge.data.frame(modelsReps,Reps_FC,by = 'GeneID')\n\n\n        data_merged_2<-data.frame(data_merged_2,\"Top_minus_min\"=data_merged_2$predX1-data_merged_2[,paste(\"predX\",(chans-1),sep = \"\")])\n\n        data_merged_2<- data.frame(data_merged_2, correctedRB50 = (data_merged_2$RB50Coef*data_merged_2$depletionConstant))\n        data_merged_2\n\n      } else {\n\n        final.Names <- paste0('rep1_C',0:(chans - 2 ))\n        pred.names <- paste0('predX',1:(chans -1))\n        colnames(data.merged[,1:(chans -1)]) <- final.Names\n        data_merged_positives<- data.merged\n        # na.omit(data.merged[data.merged[,1:chans] >= 1,])\n\n        data_merged_positives2<-( (1/data_merged_positives[,1:(chans -1 )]))*100\n        Reps_FC<-data.frame(data_merged_positives2 ,\n                            Accession =  data_merged_positives$Accession,GeneID = data_merged_positives$GeneID,\n                            UniquePeps = data_merged_positives$UniquePeps\n        )\n\n\n        ryegrass.m1 <- vector(mode = \"list\",length = nrow(Reps_FC))\n        pvals <- vector(mode = \"list\",length = nrow(Reps_FC))\n        stderr <- vector(mode = \"list\",length = nrow(Reps_FC))\n        model_pred <- vector(mode = \"list\",length = nrow(Reps_FC))\n        coeff_predicted <- vector(mode = \"list\",length = nrow(Reps_FC))\n        for(i in 1:nrow(Reps_FC)){\n          #print(i)\n\n          #nrow(full_df_2)\n          #maxIt and relTol to be user defined\n          ryegrass.m1[[i]]<-try(drc::drm(as.numeric(Reps_FC[i,1:(chans - 1 )]) ~ as.numeric(conc),\n                                         na.action = stats::na.omit,\n                                         control = drc::drmc(constr = FALSE, errorm = FALSE, noMessage = TRUE, maxIt = 1000, relTol = 1e-06),\n                                         fct = drc::LL.4(fixed=c(NA, NA, NA, NA), #see note @top this file\n                                                         names = c(\"Slope\", \"Lower Limit\", \"Upper Limit\", \"RB50\"))),silent = TRUE)\n\n        }\n\n        failed_sigm=0\n        for(i in 1:length(ryegrass.m1)){\n          #print(i)\n          #checking_val if FALSE  the model has failed to calculate the pval\n          checking_val<-try(is.numeric(vsn::coefficients(ryegrass.m1[[i]])[[\"Slope:(Intercept)\"]]),silent = TRUE)\n\n          if(checking_val==\"TRUE\"){\n            #print(checking_val)\n            pvals[[i]]<-t(as.data.frame(suppressWarnings(summary(ryegrass.m1[[i]])$coefficients[13:16])))\n            colnames(pvals[[i]])<-c(\"SlopePval\", \"Lower_LimitPval\", \"Upper_LimitPval\", \"RB50Pval\")\n            coeff_predicted[[i]]<-t(data.frame(suppressWarnings(vsn::coefficients(ryegrass.m1[[i]]))))\n            colnames(coeff_predicted[[i]])<-c(\"SlopeCoef\", \"Lower_LimitCoef\", \"Upper_LimitCoef\",\"RB50Coef\")\n            stderr[[i]]<-t(as.data.frame(suppressWarnings(summary(ryegrass.m1[[i]])$coefficients[5:8])))\n            colnames(stderr[[i]])<-c(\"SlopeErr\", \"Lower_LimitErr\", \"Upper_LimitErr\",\"RB50Err\")\n\n            model_pred[[i]]<-suppressWarnings(predict(ryegrass.m1[[i]]))\n          }else{\n            failed_sigm=failed_sigm+1\n\n            fit <- stats::lm(as.numeric(Reps_FC[i,1:(chans -1)]) ~ poly(log10(conc),2 ))\n            #extract the pval\n            pval<-as.numeric(summary(fit)$coefficients[,4] )\n            pvals[[i]]<- t(as.data.frame(c(pval,\"lm-fit:intercept.slope.quadratic\") ))\n            colnames(pvals[[i]])<-c(\"SlopePval\", \"Lower_LimitPval\", \"Upper_LimitPval\",\"RB50Pval\")\n            stderr[[i]]<- data.frame(NA,NA,NA,NA)\n            colnames(stderr[[i]])<-c(\"SlopeErr\", \"Lower_LimitErr\", \"Upper_LimitErr\",\"RB50Err\")\n            coeff_predicted[[i]]<-data.frame(NA,NA,NA,NA)\n            colnames(coeff_predicted[[i]])<-c(\"SlopeCoef\", \"Lower_LimitCoef\", \"Upper_LimitCoef\",\"RB50Coef\")\n            model_pred[[i]]<- as.numeric(stats::fitted(fit))\n          } #just adding NAs for the times the model failed\n        }\n\n\n        modelsReps<-data.frame(\n          do.call(rbind.data.frame,lapply(model_pred,function(x) as.numeric(x))),\n          Reps_FC$GeneID,\n          do.call(rbind.data.frame,lapply(pvals,function(x) x) ),\n          do.call(rbind.data.frame,lapply(coeff_predicted,function(x) x)) ,\n          do.call(rbind.data.frame,lapply(stderr,function(x) x) )\n        )\n        colnames(modelsReps)<-c(pred.names,\"GeneID\",\n                                \"SlopePval\", \"Lower_LimitPval\",\"Upper_LimitPval\", \"RB50Pval\",\n                                \"SlopeCoef\", \"Lower_LimitCoef\",\"Upper_LimitCoef\", \"RB50Coef\",\n                                \"SlopeErr\", \"Lower_LimitErr\",\"Upper_LimitErr\", \"RB50Err\"\n        )\n\n        data_merged_2 <-merge.data.frame(modelsReps,Reps_FC,by = 'GeneID')\n\n        data_merged_2<-data.frame(data_merged_2,\"Top_minus_min\"=data_merged_2$predX1-data_merged_2[,paste(\"predX\",(chans-1),sep = \"\")])\n\n        data_merged_2\n\n      }\n\n\n    } else{\n\n      nvec <- 1:chans\n      nvec <- length(nvec)\n      data.merged <- dataFrame\n\n      conc <- sigmoidConc\n      final.Names <- standard_names(chans,reps,dataType = 'LFC')\n      pred.names <-  paste0(\"predX\",1:chans)\n      colnames(data.merged[,1:chans]) <- final.Names\n      data_merged_positives<- data.merged\n      # na.omit(data.merged[data.merged[,1:chans] >= 1,])\n\n      data_merged_positives2<-( (1/data_merged_positives[,1:chans]))*100\n      if(incPDofPD == TRUE){\n        Reps_FC<-data.frame(data_merged_positives2 ,\n                            Accession =  data_merged_positives$Accession,GeneID = data_merged_positives$GeneID,\n                            UniquePeps = data_merged_positives$UniquePeps, depletionConstant = data_merged_positives$Kd, MissingVal = data_merged_positives$MissingVal\n        )\n      }else{\n        Reps_FC<-data.frame(data_merged_positives2 ,\n                            Accession =  data_merged_positives$Accession,GeneID = data_merged_positives$GeneID,\n                            UniquePeps = data_merged_positives$UniquePeps, MissingVal = data_merged_positives$MissingVal\n        )\n      }\n\n      ryegrass.m1<- vector(mode = 'list',length = dim(data_merged_positives)[1])\n      pvals<- vector(mode = 'list',length = dim(data_merged_positives)[1])\n      stderr<- vector(mode = 'list',length = dim(data_merged_positives)[1])\n      model_pred<- vector(mode = 'list',length = dim(data_merged_positives)[1])\n      coeff_predicted<- vector(mode = 'list',length = dim(data_merged_positives)[1])\n      for(i in 1:nrow(Reps_FC)){\n\n        #nrow(full_df_2)\n        #maxIt and relTol to be user defined\n        ryegrass.m1[[i]]<- suppressWarnings(try(drc::drm(as.numeric(Reps_FC[i,1:chans]) ~ as.numeric(conc),\n                                                         na.action = stats::na.omit,\n                                                         control = drc::drmc(constr = FALSE, errorm = FALSE, noMessage = TRUE, maxIt = 1000, relTol = 1e-06),\n                                                         fct = drc::LL.4(fixed=c(NA, NA, NA, NA),  #see note @top this file\n                                                                         names = c(\"Slope\", \"Lower Limit\", \"Upper Limit\", \"RB50\"))),silent = TRUE))\n\n      }\n      failed_sigm=0\n      for(i in 1:length(ryegrass.m1)){\n        #print(i)\n        #checking_val if FALSE  the model has failed to calculate the pval\n        checking_val <- try(is.numeric(vsn::coefficients(ryegrass.m1[[i]])[[\"Slope:(Intercept)\"]]),silent = TRUE)\n\n        if(checking_val==\"TRUE\"){\n          #print(checking_val)\n          pvals[[i]]<-t(as.data.frame(suppressWarnings( summary(ryegrass.m1[[i]])$coefficients[13:16])))\n          colnames(pvals[[i]])<-c(\"SlopePval\", \"Lower_LimitPval\", \"Upper_LimitPval\", \"RB50Pval\")\n          coeff_predicted[[i]]<-t(data.frame(vsn::coefficients(ryegrass.m1[[i]])))\n          colnames(coeff_predicted[[i]])<-c(\"SlopeCoef\", \"Lower_LimitCoef\", \"Upper_LimitCoef\",\"RB50Coef\")\n          stderr[[i]]<-t(as.data.frame(suppressWarnings(summary(ryegrass.m1[[i]])$coefficients[5:8])))\n          colnames(stderr[[i]])<-c(\"SlopeErr\", \"Lower_LimitErr\", \"Upper_LimitErr\",\"RB50Err\")\n\n          model_pred[[i]] <- suppressWarnings(predict(ryegrass.m1[[i]]))\n        }else{\n          failed_sigm=failed_sigm+1\n\n          fit <- stats::lm(as.numeric(Reps_FC[i,1:chans]) ~ poly(log10(conc),2 ))\n          #extract the pval\n          pval<-as.numeric(summary(fit)$coefficients[,4] )\n          pvals[[i]]<- t(as.data.frame(c(pval,\"lm-fit:intercept.slope.quadratic\") ))\n          colnames(pvals[[i]])<-c(\"SlopePval\", \"Lower_LimitPval\", \"Upper_LimitPval\",\"RB50Pval\")\n          stderr[[i]]<- data.frame(NA,NA,NA,NA)\n          colnames(stderr[[i]])<-c(\"SlopeErr\", \"Lower_LimitErr\", \"Upper_LimitErr\",\"RB50Err\")\n          coeff_predicted[[i]]<-data.frame(NA,NA,NA,NA)\n          colnames(coeff_predicted[[i]])<-c(\"SlopeCoef\", \"Lower_LimitCoef\", \"Upper_LimitCoef\",\"RB50Coef\")\n          model_pred[[i]]<- as.numeric(stats::fitted(fit))\n        } #just adding NAs for the times the model failed\n      }\n\n\n      modelsReps<-data.frame(\n        do.call(rbind.data.frame,lapply(model_pred,function(x) as.numeric(x))),\n        Reps_FC$GeneID,\n        do.call(rbind.data.frame,lapply(pvals,function(x) x) ),\n        do.call(rbind.data.frame,lapply(coeff_predicted,function(x) x)) ,\n        do.call(rbind.data.frame,lapply(stderr,function(x) x) )\n      )\n      colnames(modelsReps)<-c(pred.names,\"GeneID\",\n                              \"SlopePval\", \"Lower_LimitPval\",\"Upper_LimitPval\", \"RB50Pval\",\n                              \"SlopeCoef\", \"Lower_LimitCoef\",\"Upper_LimitCoef\", \"RB50Coef\",\n                              \"SlopeErr\", \"Lower_LimitErr\",\"Upper_LimitErr\", \"RB50Err\"\n      )\n      data_merged_2<-merge.data.frame(modelsReps,Reps_FC,by=\"GeneID\")\n\n      data_merged_2<-data.frame(data_merged_2,\"Top_minus_min\"=data_merged_2$predX1-data_merged_2[,paste(\"predX\",chans,sep = \"\")])\n\n      if(incPDofPD == TRUE){\n\n        data_merged_2<- data.frame(data_merged_2, correctedRB50 = (data_merged_2$RB50Coef*data_merged_2$depletionConstant))\n      }else{\n        data_merged_2<- data.frame(data_merged_2)\n      }\n      data_merged_2\n\n    }\n\n  } else{\n    if(dataType == \"intensity\"){\n      nvec <- 1:((chans-1)*(reps -1))\n      nvec <- length(nvec)\n      data.merged <- dataFrame\n      conc<- rep(0:(chans - 2), times = reps)\n\n    }else{\n      nvec <- 1:((chans)*(reps))\n      nvec <- length(nvec)\n      data.merged <- dataFrame\n      conc<- rep(0:(chans - 1), times = reps)[1:(chans*reps)]\n\n    }\n\n    design <- stats::model.matrix(~poly(conc,2))\n    colnames(design)<-c(\"Intercept\",\"Slope\",\"Quadratic\")\n\n    # reactive start\n\n    fit <- limma::lmFit(data.merged[,1:length(conc)], method = \"ls\" , design = design )\n    fit <- limma::eBayes(fit)\n\n    res <- limma::topTable(fit, coef = \"Slope\", number = nrow(data.merged), adjust=\"BH\") #pval for the slope\n    res2 <- limma::topTable(fit, coef = 1, number = nrow(data.merged), adjust=\"BH\")#pval for the intercept\n    res3 <- limma::topTable(fit, coef = \"Quadratic\", number = nrow(data.merged), adjust=\"BH\") #pval for the quadratic term ()\n\n\n    #add the pvalues to the dataframe\n\n    tmp_1<- cbind(data.merged[rownames(res),],res)\n\n    tmp_2<- cbind(data.merged[rownames(res2),],res2)\n\n    tmp_3<- cbind(data.merged[rownames(res3),],res3)\n\n    ####\n\n\n\n    tobeselected <- merge.data.frame(tmp_1,tmp_2,by=\"Accession\")\n    tobeselected <- merge.data.frame(tobeselected,tmp_3,by=\"Accession\")\n\n    selectnames <- c(paste0(colnames(data.merged)[1:length(conc)],\".x\"),\n                     \"logFC.x\", \"AveExpr.x\", \"P.Value\", \"adj.P.Val\", \"P.Value.x\",\n                     \"adj.P.Val.x\", \"P.Value.y\", \"adj.P.Val.y\",\"Accession\",\"GeneID.x\",\"UniquePeps\")\n\n    # can create a replacement names function here ....\n\n\n    data.merged<- tobeselected[,match(selectnames, colnames(tobeselected))]\n\n    nam <- standard_names(chans, reps, dataType)\n\n    if(dataType == 'intensity'){\n      nam <- nam[-seq(1,reps*chans,by = chans)]\n    }\n    colnames(data.merged)[1:length(nam)] <- nam\n\n    colnames(data.merged) <-  c(nam,\n                                \"logFC\", \"AveExpr\", \"P.Value_slope\", \"adj.P.Val_slope\", \"P.Value_intercept\",\n                                \"adj.P.Val_intercept\", \"P.Value_quadratic\", \"adj.P.Val_quadratic\",\"Accession\",\"GeneID\",\"UniquePeps\")\n\n\n    data.merged\n  }\n\n}\n",
    "created" : 1497098205348.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "2|49|16|0|\n19|59|85|0|\n243|8|245|2|\n263|8|268|2|\n270|16|288|2|\n325|12|352|6|\n355|10|405|4|\n851|10|854|4|\n856|31|859|4|\n899|37|907|8|\n",
    "hash" : "842675951",
    "id" : "24EF1B21",
    "lastKnownWriteTime" : 1498773526,
    "last_content_update" : 1498773549373,
    "path" : "~/Desktop/Doscheda/R/non_exported.R",
    "project_path" : "R/non_exported.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 8,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}
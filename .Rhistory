corrplot::corrplot
POST
??POST
?@imoirt
?@imoportt
?@imoport
vignette("roxygen2")
sessionInfo()
library(Doscheda)
library(affy)
library(affy)
library(affy)
source("https://bioconductor.org/biocLite.R")
biocLite("affy")
biocLite('limma')
biocLite('httr')
biocLite('vsn')
library(Doscheda)
install.packages("roxygen2")
library(Doscheda)
library(Doscheda)
library(Doscheda)
library(Doscheda)
library(Doscheda)
install.packages('drc')
library(drc)
?predict
?lm
library(Doscheda)
library(Doscheda)
library(Doscheda)
library(Doscheda)
library(vsn)
meanSdPlot()
?meanSdPlot
library(Doscheda)
library(Doscheda)
library(Doscheda)
library(Doscheda)
library(Doscheda)
library(devtools)
install.packages("devtools")
library(devtools)
library(Doscheda)
??coefficients
library(Doscheda)
library(Doscheda)
library(Doscheda)
predict()
predict
showMethods(predict)
library(Doscheda)
fit_model <- function(dataFrame , chans, reps, dataType = 'LFC', modelType = 'sigmoid', sigmoidConc = NA,  PD2 = TRUE,incPDofPD = FALSE, PDofPD = NA){
if(modelType == "sigmoid"){
if(dataType == 'intensity'){
nvec <- 1:(chans -1)
nvec <- length(nvec)
data.merged <- dataFrame
conc <- sigmoidConc
if(incPDofPD == TRUE){
final.Names <- paste0('rep1_C',0:(chans - 2 ))
pred.names <- paste0('predX',1:(chans -1))
colnames(data.merged[,1:(chans -1)]) <- final.Names
data_merged_positives<- data.merged
# na.omit(data.merged[data.merged[,1:chans] >= 1,])
data_merged_positives2<-( (1/data_merged_positives[,1:(chans -1 )]))*100
Reps_FC<-data.frame(data_merged_positives2 ,
Accession =  data_merged_positives$Accession,GeneID = data_merged_positives$GeneID,
UniquePeps = data_merged_positives$UniquePeps, depletionConstant = data_merged_positives$Kd
)
ryegrass.m1<- vector(mode = "list",length = nrow(Reps_FC))
pvals<- vector(mode = "list",length = nrow(Reps_FC))
stderr<- vector(mode = "list",length = nrow(Reps_FC))
model_pred<- vector(mode = "list",length = nrow(Reps_FC))
coeff_predicted<- vector(mode = "list",length = nrow(Reps_FC))
for(i in 1:nrow(Reps_FC)){
#print(i)
#nrow(full_df_2)
#maxIt and relTol to be user defined
ryegrass.m1[[i]]<-try(drc::drm(as.numeric(Reps_FC[i,1:(chans - 1 )]) ~ as.numeric(conc),
na.action = stats::na.omit,
control = drc::drmc(constr = FALSE, errorm = FALSE, noMessage = TRUE, maxIt = 1000, relTol = 1e-06),
fct = drc::LL.4(fixed=c(NA, NA, NA, NA), #see note @top this file
names = c("Slope", "Lower Limit", "Upper Limit", "RB50"))),silent = T)
}
failed_sigm=0
for(i in 1:length(ryegrass.m1)){
#print(i)
#checking_val if FALSE  the model has failed to calculate the pval
checking_val<-try(is.numeric(vsn::coefficients(ryegrass.m1[[i]])[["Slope:(Intercept)"]]),silent = T)
if(checking_val=="TRUE"){
#print(checking_val)
pvals[[i]]<-t(as.data.frame(summary(ryegrass.m1[[i]])$coefficients[13:16]))
colnames(pvals[[i]])<-c("SlopePval", "Lower_LimitPval", "Upper_LimitPval", "RB50Pval")
coeff_predicted[[i]]<-t(data.frame(vsn::coefficients(ryegrass.m1[[i]])))
colnames(coeff_predicted[[i]])<-c("SlopeCoef", "Lower_LimitCoef", "Upper_LimitCoef","RB50Coef")
stderr[[i]]<-t(as.data.frame(summary(ryegrass.m1[[i]])$coefficients[5:8]))
colnames(stderr[[i]])<-c("SlopeErr", "Lower_LimitErr", "Upper_LimitErr","RB50Err")
model_pred[[i]]<-predict(ryegrass.m1[[i]])
}else{
failed_sigm=failed_sigm+1
fit <- lm(as.numeric(Reps_FC[i,1:(chans -1)]) ~ poly(log10(conc),2 ))
#extract the pval
pval<-as.numeric(summary(fit)$coefficients[,4] )
pvals[[i]]<- t(as.data.frame(c(pval,"lm-fit:intercept.slope.quadratic") ))
colnames(pvals[[i]])<-c("SlopePval", "Lower_LimitPval", "Upper_LimitPval","RB50Pval")
stderr[[i]]<- data.frame(NA,NA,NA,NA)
colnames(stderr[[i]])<-c("SlopeErr", "Lower_LimitErr", "Upper_LimitErr","RB50Err")
coeff_predicted[[i]]<-data.frame(NA,NA,NA,NA)
colnames(coeff_predicted[[i]])<-c("SlopeCoef", "Lower_LimitCoef", "Upper_LimitCoef","RB50Coef")
model_pred[[i]]<- as.numeric(fitted(fit))
} #just adding NAs for the times the model failed
}
modelsReps<-data.frame(
do.call(rbind.data.frame,lapply(model_pred,function(x) as.numeric(x))),
Reps_FC$GeneID,
do.call(rbind.data.frame,lapply(pvals,function(x) x) ),
do.call(rbind.data.frame,lapply(coeff_predicted,function(x) x)) ,
do.call(rbind.data.frame,lapply(stderr,function(x) x) )
)
colnames(modelsReps)<-c(pred.names,"GeneID",
"SlopePval", "Lower_LimitPval","Upper_LimitPval", "RB50Pval",
"SlopeCoef", "Lower_LimitCoef","Upper_LimitCoef", "RB50Coef",
"SlopeErr", "Lower_LimitErr","Upper_LimitErr", "RB50Err"
)
data_merged_2 <-merge.data.frame(modelsReps,Reps_FC,by = 'GeneID')
data_merged_2<-data.frame(data_merged_2,"Top_minus_min"=data_merged_2$predX1-data_merged_2[,paste("predX",(chans-1),sep = "")])
data_merged_2<- data.frame(data_merged_2, correctedRB50 = (data_merged_2$RB50Coef*data_merged_2$depletionConstant))
data_merged_2
} else {
final.Names <- paste0('rep1_C',0:(chans - 2 ))
pred.names <- paste0('predX',1:(chans -1))
colnames(data.merged[,1:(chans -1)]) <- final.Names
data_merged_positives<- data.merged
# na.omit(data.merged[data.merged[,1:chans] >= 1,])
data_merged_positives2<-( (1/data_merged_positives[,1:(chans -1 )]))*100
Reps_FC<-data.frame(data_merged_positives2 ,
Accession =  data_merged_positives$Accession,GeneID = data_merged_positives$GeneID,
UniquePeps = data_merged_positives$UniquePeps
)
ryegrass.m1 <- vector(mode = "list",length = nrow(Reps_FC))
pvals <- vector(mode = "list",length = nrow(Reps_FC))
stderr <- vector(mode = "list",length = nrow(Reps_FC))
model_pred <- vector(mode = "list",length = nrow(Reps_FC))
coeff_predicted <- vector(mode = "list",length = nrow(Reps_FC))
for(i in 1:nrow(Reps_FC)){
#print(i)
#nrow(full_df_2)
#maxIt and relTol to be user defined
ryegrass.m1[[i]]<-try(drc::drm(as.numeric(Reps_FC[i,1:(chans - 1 )]) ~ as.numeric(conc),
na.action = stats::na.omit,
control = drc::drmc(constr = FALSE, errorm = FALSE, noMessage = TRUE, maxIt = 1000, relTol = 1e-06),
fct = drc::LL.4(fixed=c(NA, NA, NA, NA), #see note @top this file
names = c("Slope", "Lower Limit", "Upper Limit", "RB50"))),silent = T)
}
failed_sigm=0
for(i in 1:length(ryegrass.m1)){
#print(i)
#checking_val if FALSE  the model has failed to calculate the pval
checking_val<-try(is.numeric(vsn::coefficients(ryegrass.m1[[i]])[["Slope:(Intercept)"]]),silent = T)
if(checking_val=="TRUE"){
#print(checking_val)
pvals[[i]]<-t(as.data.frame(suppressWarnings(summary(ryegrass.m1[[i]])$coefficients[13:16])))
colnames(pvals[[i]])<-c("SlopePval", "Lower_LimitPval", "Upper_LimitPval", "RB50Pval")
coeff_predicted[[i]]<-t(data.frame(suppressWarnings(vsn::coefficients(ryegrass.m1[[i]]))))
colnames(coeff_predicted[[i]])<-c("SlopeCoef", "Lower_LimitCoef", "Upper_LimitCoef","RB50Coef")
stderr[[i]]<-t(as.data.frame(suppressWarnings(summary(ryegrass.m1[[i]])$coefficients[5:8])))
colnames(stderr[[i]])<-c("SlopeErr", "Lower_LimitErr", "Upper_LimitErr","RB50Err")
model_pred[[i]]<-suppressWarnings(predict(ryegrass.m1[[i]]))
}else{
failed_sigm=failed_sigm+1
fit <- lm(as.numeric(Reps_FC[i,1:(chans -1)]) ~ poly(log10(conc),2 ))
#extract the pval
pval<-as.numeric(summary(fit)$coefficients[,4] )
pvals[[i]]<- t(as.data.frame(c(pval,"lm-fit:intercept.slope.quadratic") ))
colnames(pvals[[i]])<-c("SlopePval", "Lower_LimitPval", "Upper_LimitPval","RB50Pval")
stderr[[i]]<- data.frame(NA,NA,NA,NA)
colnames(stderr[[i]])<-c("SlopeErr", "Lower_LimitErr", "Upper_LimitErr","RB50Err")
coeff_predicted[[i]]<-data.frame(NA,NA,NA,NA)
colnames(coeff_predicted[[i]])<-c("SlopeCoef", "Lower_LimitCoef", "Upper_LimitCoef","RB50Coef")
model_pred[[i]]<- as.numeric(fitted(fit))
} #just adding NAs for the times the model failed
}
modelsReps<-data.frame(
do.call(rbind.data.frame,lapply(model_pred,function(x) as.numeric(x))),
Reps_FC$GeneID,
do.call(rbind.data.frame,lapply(pvals,function(x) x) ),
do.call(rbind.data.frame,lapply(coeff_predicted,function(x) x)) ,
do.call(rbind.data.frame,lapply(stderr,function(x) x) )
)
colnames(modelsReps)<-c(pred.names,"GeneID",
"SlopePval", "Lower_LimitPval","Upper_LimitPval", "RB50Pval",
"SlopeCoef", "Lower_LimitCoef","Upper_LimitCoef", "RB50Coef",
"SlopeErr", "Lower_LimitErr","Upper_LimitErr", "RB50Err"
)
data_merged_2 <-merge.data.frame(modelsReps,Reps_FC,by = 'GeneID')
data_merged_2<-data.frame(data_merged_2,"Top_minus_min"=data_merged_2$predX1-data_merged_2[,paste("predX",(chans-1),sep = "")])
data_merged_2
}
} else{
nvec <- 1:chans
nvec <- length(nvec)
data.merged <- dataFrame
conc <- sigmoidConc
final.Names <- standard_names(chans,reps,dataType = 'LFC')
pred.names <-  paste0("predX",1:chans)
colnames(data.merged[,1:chans]) <- final.Names
data_merged_positives<- data.merged
# na.omit(data.merged[data.merged[,1:chans] >= 1,])
data_merged_positives2<-( (1/data_merged_positives[,1:chans]))*100
if(incPDofPD == TRUE){
Reps_FC<-data.frame(data_merged_positives2 ,
Accession =  data_merged_positives$Accession,GeneID = data_merged_positives$GeneID,
UniquePeps = data_merged_positives$UniquePeps, depletionConstant = data_merged_positives$Kd, MissingVal = data_merged_positives$MissingVal
)
}else{
Reps_FC<-data.frame(data_merged_positives2 ,
Accession =  data_merged_positives$Accession,GeneID = data_merged_positives$GeneID,
UniquePeps = data_merged_positives$UniquePeps, MissingVal = data_merged_positives$MissingVal
)
}
ryegrass.m1<- vector(mode = 'list',length = dim(data_merged_positives)[1])
pvals<- vector(mode = 'list',length = dim(data_merged_positives)[1])
stderr<- vector(mode = 'list',length = dim(data_merged_positives)[1])
model_pred<- vector(mode = 'list',length = dim(data_merged_positives)[1])
coeff_predicted<- vector(mode = 'list',length = dim(data_merged_positives)[1])
for(i in 1:nrow(Reps_FC)){
#nrow(full_df_2)
#maxIt and relTol to be user defined
ryegrass.m1[[i]]<- suppressWarnings(try(drc::drm(as.numeric(Reps_FC[i,1:chans]) ~ as.numeric(conc),
na.action = stats::na.omit,
control = drc::drmc(constr = FALSE, errorm = FALSE, noMessage = TRUE, maxIt = 1000, relTol = 1e-06),
fct = drc::LL.4(fixed=c(NA, NA, NA, NA),  #see note @top this file
names = c("Slope", "Lower Limit", "Upper Limit", "RB50"))),silent = T))
}
failed_sigm=0
for(i in 1:length(ryegrass.m1)){
#print(i)
#checking_val if FALSE  the model has failed to calculate the pval
checking_val <- try(is.numeric(vsn::coefficients(ryegrass.m1[[i]])[["Slope:(Intercept)"]]),silent = T)
if(checking_val=="TRUE"){
#print(checking_val)
pvals[[i]]<-t(as.data.frame(suppressWarnings( summary(ryegrass.m1[[i]])$coefficients[13:16])))
colnames(pvals[[i]])<-c("SlopePval", "Lower_LimitPval", "Upper_LimitPval", "RB50Pval")
coeff_predicted[[i]]<-t(data.frame(vsn::coefficients(ryegrass.m1[[i]])))
colnames(coeff_predicted[[i]])<-c("SlopeCoef", "Lower_LimitCoef", "Upper_LimitCoef","RB50Coef")
stderr[[i]]<-t(as.data.frame(suppressWarnings(summary(ryegrass.m1[[i]])$coefficients[5:8])))
colnames(stderr[[i]])<-c("SlopeErr", "Lower_LimitErr", "Upper_LimitErr","RB50Err")
model_pred[[i]] <- suppressWarnings(predict(ryegrass.m1[[i]]))
}else{
failed_sigm=failed_sigm+1
fit <- lm(as.numeric(Reps_FC[i,1:chans]) ~ poly(log10(conc),2 ))
#extract the pval
pval<-as.numeric(summary(fit)$coefficients[,4] )
pvals[[i]]<- t(as.data.frame(c(pval,"lm-fit:intercept.slope.quadratic") ))
colnames(pvals[[i]])<-c("SlopePval", "Lower_LimitPval", "Upper_LimitPval","RB50Pval")
stderr[[i]]<- data.frame(NA,NA,NA,NA)
colnames(stderr[[i]])<-c("SlopeErr", "Lower_LimitErr", "Upper_LimitErr","RB50Err")
coeff_predicted[[i]]<-data.frame(NA,NA,NA,NA)
colnames(coeff_predicted[[i]])<-c("SlopeCoef", "Lower_LimitCoef", "Upper_LimitCoef","RB50Coef")
model_pred[[i]]<- as.numeric(fitted(fit))
} #just adding NAs for the times the model failed
}
modelsReps<-data.frame(
do.call(rbind.data.frame,lapply(model_pred,function(x) as.numeric(x))),
Reps_FC$GeneID,
do.call(rbind.data.frame,lapply(pvals,function(x) x) ),
do.call(rbind.data.frame,lapply(coeff_predicted,function(x) x)) ,
do.call(rbind.data.frame,lapply(stderr,function(x) x) )
)
colnames(modelsReps)<-c(pred.names,"GeneID",
"SlopePval", "Lower_LimitPval","Upper_LimitPval", "RB50Pval",
"SlopeCoef", "Lower_LimitCoef","Upper_LimitCoef", "RB50Coef",
"SlopeErr", "Lower_LimitErr","Upper_LimitErr", "RB50Err"
)
data_merged_2<-merge.data.frame(modelsReps,Reps_FC,by="GeneID")
data_merged_2<-data.frame(data_merged_2,"Top_minus_min"=data_merged_2$predX1-data_merged_2[,paste("predX",chans,sep = "")])
if(incPDofPD == TRUE){
data_merged_2<- data.frame(data_merged_2, correctedRB50 = (data_merged_2$RB50Coef*data_merged_2$depletionConstant))
}else{
data_merged_2<- data.frame(data_merged_2)
}
data_merged_2
}
} else{
if(dataType == "intensity"){
nvec <- 1:((chans-1)*(reps -1))
nvec <- length(nvec)
data.merged <- dataFrame
conc<- rep(0:(chans - 2), times = reps)
}else{
nvec <- 1:((chans)*(reps))
nvec <- length(nvec)
data.merged <- dataFrame
conc<- rep(0:(chans - 1), times = reps)[1:(chans*reps)]
}
design<-model.matrix(~poly(conc,2))
colnames(design)<-c("Intercept","Slope","Quadratic")
# reactive start
fit <- lmFit(data.merged[,1:length(conc)], method = "ls" , design = design )
fit <- eBayes(fit)
res <- topTable(fit, coef = "Slope", number = nrow(data.merged), adjust="BH") #pval for the slope
res2 <- topTable(fit, coef = 1, number = nrow(data.merged), adjust="BH")#pval for the intercept
res3 <- topTable(fit, coef = "Quadratic", number = nrow(data.merged), adjust="BH") #pval for the quadratic term ()
#add the pvalues to the dataframe
tmp_1<- cbind(data.merged[rownames(res),],res)
tmp_2<- cbind(data.merged[rownames(res2),],res2)
tmp_3<- cbind(data.merged[rownames(res3),],res3)
####
tobeselected <- merge.data.frame(tmp_1,tmp_2,by="Accession")
tobeselected <- merge.data.frame(tobeselected,tmp_3,by="Accession")
selectnames <- c(paste0(colnames(data.merged)[1:length(conc)],".x"),
"logFC.x", "AveExpr.x", "P.Value", "adj.P.Val", "P.Value.x",
"adj.P.Val.x", "P.Value.y", "adj.P.Val.y","Accession","GeneID.x","UniquePeps")
# can create a replacement names function here ....
data.merged<- tobeselected[,match(selectnames, colnames(tobeselected))]
nam <- standard_names(chans, reps, dataType)
if(dataType == 'intensity'){
nam <- nam[-seq(1,reps*chans,by = chans)]
}
colnames(data.merged)[1:length(nam)] <- nam
colnames(data.merged) <-  c(nam,
"logFC", "AveExpr", "P.Value_slope", "adj.P.Val_slope", "P.Value_intercept",
"adj.P.Val_intercept", "P.Value_quadratic", "adj.P.Val_quadratic","Accession","GeneID","UniquePeps")
data.merged
}
}
library(Doscheda)
model.ma
library(stringr)
library(Doscheda)
?strwidth
?text
..count.. <- 2
..count..
library(ggplot2)
install.packages("gridExtra")
library(Doscheda)
library(Doscheda)
?cor.test()
?terrain.colors
boxpot()
boxplot()
boxplot
showMethods(boxplot)
library(Doscheda)
library(Doscheda)
Doscheda:::DoschedaSet
library(devtools)
library(Doscheda)
organism
library(Doscheda)
library(Doscheda)
vsn::meanSdPlot
plot
plot.ChemoProtSet <- function(x, ...) {
inherits(x, 'ChemoProtSet')
if(x@parameters$modelType == 'linear'){
data.merged<- x@finalData
m0 <- ggplot2::ggplot(data.merged, ggplot2::aes(x=data.merged$P.Value_slope))
m0<-m0 + geom_histogram(ggplot2::aes(fill = ..count..),binwidth = 0.01) +
ggplot2::scale_fill_gradient("Count", low = "green", high = "red")+
ggplot2::xlab("P.val slope")
m1 <- ggplot2::ggplot(data.merged, ggplot2::aes(x=data.merged$P.Value_intercept))
m1<- m1 + geom_histogram(ggplot2::aes(fill = ..count..),binwidth = 0.01) +
ggplot2::scale_fill_gradient("Count", low = "green", high = "red")+
ggplot2::xlab("Pval intercept")
m2 <- ggplot2::ggplot(data.merged, ggplot2::aes(x=data.merged$P.Value_quadratic))
m2 <- m2 + geom_histogram(ggplot2::aes(fill = ..count..),binwidth = 0.01) +
ggplot2::scale_fill_gradient("Count", low = "green", high = "red")+
ggplot2::xlab("Pval quadratic")
gridExtra::grid.arrange(m0,m1,m2)
} else {
graphics::par(mfrow = c(2,2))
data_merged_2 <- x@finalData
conc<- x@parameters$sigmoidConc
topperc <- 30 #difference in % between top and bottom
if(x@parameters$dataType == 'intensity'){
pred.names <- paste0('predX',1:(x@parameters$chans -1))
final.Names <- paste0('rep1_C',0:(x@parameters$chans - 2))
diffinter<- data_merged_2[(data_merged_2$predX1 - data_merged_2[,paste("predX",(x@parameters$chans-1),sep = "")]) > topperc & data_merged_2$predX1 <= 100, ]
} else {
pred.names <- paste0('predX',1:(x@parameters$chans))
final.Names <- paste0('rep1_C',0:(x@parameters$chans - 1))
diffinter<- data_merged_2[(data_merged_2$predX1 - data_merged_2[,paste("predX",(x@parameters$chans),sep = "")]) > topperc & data_merged_2$predX1 <= 100, ]
}
if(nrow(diffinter) > 0){
Diff_Top_bottom_pred <- shape_for_ggplot_pred(diffinter,log2(conc),pred.names)
Diff_Top_bottom_perc <- shape_for_ggplot_perc(diffinter,log2(conc),final.Names)
what<-c("(Top - Bottom) >")
GeneID <- factor(Diff_Top_bottom_pred$GeneID)
Diff_Top_bottom<-ggplot2::ggplot()+
ggplot2::geom_line(data = Diff_Top_bottom_pred, ggplot2::aes(x=x,y=value, colour = GeneID), size = 1) +
ggplot2::geom_point(data = Diff_Top_bottom_perc, ggplot2::aes(x=x,y=value, colour=Diff_Top_bottom_perc$GeneID)) +
ggplot2::labs(title=paste(what,topperc,sep=""))
Diff_Top_bottom
}else{
Diff_Top_bottom<-ggplot2::ggplot()+
ggplot2::labs(title=paste("No significant Top-Bottom >" ,topperc,"%","\n","has been found", sep=""))
}
## next plot (SLOPE)
top<-15 #max prot to plot
if(x@parameters$dataType == 'intensity'){
pred.names <- paste0('predX',1:(x@parameters$chans -1))
final.Names <- paste0('rep1_C',0:(x@parameters$chans - 2))
}else{
pred.names <- paste0('predX',1:(x@parameters$chans))
final.Names <- paste0('rep1_C',0:(x@parameters$chans - 1))
}
data_merged_2 <- x@finalData
#Here make the subselections for using the ggplot functions SLOPE
slope<-stats::na.omit(data_merged_2[data_merged_2$SlopePval<0.05 ,])
slope_ordered<-stats::na.omit(slope[order(slope$SlopePval, decreasing = F),][1:top,])
if(nrow(slope_ordered)>0){
slope_pred<-shape_for_ggplot_pred(slope_ordered,log10(conc),pred.names)
slope_perc<- shape_for_ggplot_perc(slope_ordered,log10(conc),final.Names)
what<-c("Slope (p.val) ")
GeneID <- factor(slope_pred$GeneID)
Slope_pl<-ggplot2::ggplot()+
ggplot2::geom_line(data = slope_pred, ggplot2::aes(x=x,y = value, colour = GeneID), size = 1) +
ggplot2::geom_point(data = slope_perc, ggplot2::aes(x=x,y = value,colour=slope_perc$GeneID))+
ggplot2::labs(title=paste(what,"Top",top,sep=""))
Slope_pl
}else{Slope_pl<-ggplot2::ggplot()+
ggplot2::labs(title="No significant Sigmoidal Slope has been found")
}
##### next plot (RB50)
top<-15 #max prot to plot
# RB50<-na.omit(data_merged_2[data_merged_2$RB50Err < as.numeric(summary(data_merged_2$RB50Err)[5]) & data_merged_2$RB50Pval<0.05 & data_merged_2$predX1-data_merged_2$predX9 >0 & data_merged_2$predX1 <= 100,])
RB50 <- data.frame(stats::na.omit(data_merged_2[data_merged_2$RB50Err < as.numeric(summary(data_merged_2$RB50Err)[5]) & data_merged_2$RB50Pval < 0.05
& data_merged_2$predX1-data_merged_2[,paste0('predX',(x@parameters$chans - 1))] >0 & data_merged_2$predX1 <= 100,]))
RB50_ordered<- stats::na.omit(RB50[order(RB50$RB50Pval, decreasing = F),][1:top,])
if(nrow(RB50_ordered)>0){
RB50_pred<-shape_for_ggplot_pred(RB50_ordered,log10(conc),pred.names)
RB50_perc<-shape_for_ggplot_perc(RB50_ordered,log10(conc),final.Names)
what<-c("RB50 (p.val) ")
GeneID <- factor(RB50_pred$GeneID)
RB50_pl<-ggplot2::ggplot()+
ggplot2::geom_line(data = RB50_pred, ggplot2::aes(x=x,y=value, colour = GeneID), size = 1) +
ggplot2::geom_point(data = RB50_perc, ggplot2::aes(x=x,y=value,colour=RB50_perc$GeneID))+
ggplot2::labs(title=paste(what,"Top",top,sep=""))
RB50_pl
}else{
RB50_pl<-ggplot2::ggplot()+
ggplot2::labs(title="No significant RB50 has been found")
print(RB50_pl)
}
lay <- matrix(c(1,3,2,3),ncol = 2)
gridExtra::grid.arrange(Diff_Top_bottom, Slope_pl, RB50_pl,layout_matrix = lay)
}
}
library(Doscheda)
library(Doscheda)
Doscheda:::DoschedaSet()
DoschedaSet()
library(Doscheda)
setwd("~/Documents/DOSCHEDA-Shiny/data/")
intensityData <- read.csv("LinearIntensities.csv", stringsAsFactors = FALSE)
channelNames <- c("Abundance..F1..126..Control..REP_1",
"Abundance..F1..127..Sample..REP_1",  "Abundance..F1..128..Sample..REP_1",  "Abundance..F1..129..Sample..REP_1",  "Abundance..F1..130..Sample..REP_1",
"Abundance..F1..131..Sample..REP_1",  "Abundance..F2..126..Control..REP_2", "Abundance..F2..127..Sample..REP_2", "Abundance..F2..128..Sample..REP_2",
"Abundance..F2..129..Sample..REP_2",  "Abundance..F2..130..Sample..REP_2", "Abundance..F2..131..Sample..REP_2")
test <- DoschedaSet()
test <- Doscheda:::DoschedaSet()
test<- setParameters(theObject = test,chansVal = 6, repsVal = 2,dataTypeStr = 'intensity', modelTypeStr = 'linear',PDBool = FALSE,removePepsBool = FALSE,incPDofPDBool = FALSE,incGeneFileBool = FALSE,organismStr = 'H.sapiens', pearsonThrshVal = 0.4)
test<- setParameters(x = test,chansVal = 6, repsVal = 2,dataTypeStr = 'intensity', modelTypeStr = 'linear',PDBool = FALSE,removePepsBool = FALSE,incPDofPDBool = FALSE,incGeneFileBool = FALSE,organismStr = 'H.sapiens', pearsonThrshVal = 0.4)
test<- setData(x = test, dataFrame = intensityData, dataChannels = channelNames, accessionChannel = "Master.Protein.Accessions",
sequenceChannel = 'Sequence', qualityChannel = "Qvality.PEP" )
test <- removePeptides(test,removePeps = FALSE)
test <- runNormalisation(test)
test<- fitModel(test)
plot(test)
library(ggplot2)
plot(test)
